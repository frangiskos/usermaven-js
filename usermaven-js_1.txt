Folder/File Structure:

├── .eslintrc.json
├── .prettierrc
├── README.md
├── examples/
│   ├── form-tracking.html
│   ├── index.html
│   └── test.ts
├── package.json
├── server/
│   └── mockServer.js
├── src/
│   ├── core/
│   │   ├── client.ts
│   │   ├── config.ts
│   │   └── types.ts
│   ├── extensions/
│   │   ├── rage-click.ts
│   │   └── scroll-depth.ts
│   ├── global.d.ts
│   ├── index.ts
│   ├── persistence/
│   │   ├── local-storage.ts
│   │   └── memory.ts
│   ├── tracking/
│   │   ├── autocapture.ts
│   │   ├── form-tracking.ts
│   │   └── pageviews.ts
│   ├── transport/
│   │   ├── beacon.ts
│   │   ├── fetch.ts
│   │   ├── https.ts
│   │   ├── transport.ts
│   │   └── xhr.ts
│   └── utils/
│       ├── autocapture-utils.ts
│       ├── common.ts
│       ├── cookie.ts
│       ├── helpers.ts
│       ├── logger.ts
│       └── queue.ts
├── test/
│   ├── setup.ts
│   ├── unit/
│   │   └── core/
│   │       ├── client.test.ts
│   │       └── server-side-client.test.ts
│   └── vitest.d.ts
├── tsconfig.json
├── vite.config.ts
└── vitest.config.ts


packages/javascript-sdk/README.md
<->
# Usermaven SDK

Usermaven SDK is a powerful and flexible JavaScript/TypeScript library for tracking user behavior and events in web applications. It supports both client-side and server-side usage, with a focus on privacy, configurability, and robustness.

## Features

- Cross-platform compatibility (browser and server-side)
- Flexible event tracking with custom payloads
- Automatic tracking of page views, form submissions, and user interactions
- Privacy-focused with configurable data sanitization
- Robust error handling and retry mechanisms
- Extensible architecture for custom tracking features
- Performance optimizations including event batching and debouncing

## Installation

### NPM or Yarn

You can install the Usermaven SDK using npm:

```bash
npm install @usermaven/sdk-js
```

Or using yarn:

```bash
yarn add @usermaven/sdk-js
```

### UMD (Universal Module Definition)

For quick integration without a module bundler, you can include the SDK directly in your HTML using a script tag:

```html
<script src="https://cdn.usermaven.com/sdk/v1/lib.js"
        data-key="your-api-key"
        data-tracking-host="https://events.yourdomain.com"
        data-log-level="debug"
        data-autocapture="true"
        data-form-tracking="true"
        data-auto-pageview="true"></script>
```

Replace `https://cdn.usermaven.com/sdk/v1/lib.js` with the actual URL where the Usermaven SDK is hosted.

## Basic Usage

### Using as a module

```javascript
import { usermavenClient } from '@usermaven/sdk-js';

const client = usermavenClient({
  apiKey: 'your-api-key',
  trackingHost: 'https://events.yourdomain.com',
  // Add other configuration options as needed
});

// Track an event
client.track('button_click', {
  buttonId: 'submit-form',
  pageUrl: window.location.href
});

// Identify a user
client.id({
  id: 'user123',
  email: 'user@example.com',
  name: 'John Doe'
});

// Track a page view
client.pageview();
```

### Using via UMD

When you include the SDK via a script tag, it automatically initializes with the configuration provided in the data attributes. You can then use the global `usermaven` function to interact with the SDK:

```html
<script>
  // Track an event
  usermaven('track', 'button_click', {
    buttonId: 'submit-form',
    pageUrl: window.location.href
  });

  // Identify a user
  usermaven('id', {
    id: 'user123',
    email: 'user@example.com',
    name: 'John Doe'
  });

  // Track a page view (if not set to automatic in the script tag)
  usermaven('pageview');
</script>
```

## Advanced Configuration

The SDK supports various configuration options to customize its behavior. When using as a module:

```javascript
const client = usermavenClient({
  apiKey: 'your-api-key',
  trackingHost: 'https://events.yourdomain.com',
  cookieDomain: '.yourdomain.com',
  logLevel: 'DEBUG',
  useBeaconApi: true,
  autocapture: true,
  formTracking: 'all',
  autoPageview: true,
  // ... other options
});
```

When using via UMD, you can set these options using data attributes on the script tag:

```html
<script src="https://cdn.usermaven.com/sdk/v1/lib.js"
        data-key="your-api-key"
        data-tracking-host="https://events.yourdomain.com"
        data-log-level="debug"
        data-autocapture="true"
        data-form-tracking="all"
        data-auto-pageview="true"
        data-use-beacon-api="true"
        data-cookie-domain=".yourdomain.com"></script>
```

Refer to the `Config` interface in `src/core/config.ts` for a full list of configuration options.

## Server-Side Usage

The SDK can also be used in server-side environments:

```javascript
const { usermavenClient } = require('@usermaven/sdk-js');

const client = usermavenClient({
  apiKey: 'your-api-key',
  trackingHost: 'https://events.yourdomain.com'
});

client.track('server_event', {
  userId: 'user123',
  action: 'item_purchased'
});
```

## Development

To set up the project for development:

1. Clone the repository
2. Install dependencies: `npm install`
3. Run tests: `npm test`
4. Build the project: `npm run build`

## Contributing

Contributions are welcome! Please read our contributing guidelines and code of conduct before submitting pull requests.

</->

packages/javascript-sdk/.eslintrc.json
<->
{
  "env": {
    "browser": true,
    "es2021": true,
    "node": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 12,
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint"],
  "rules": {}
}

</->

packages/javascript-sdk/.prettierrc
<->
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 80,
  "tabWidth": 2
}

</->

packages/javascript-sdk/examples/form-tracking.html
<->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Usermaven SDK Test</title>
    <style>
        form {
            max-width: 500px;
            margin: 20px auto;
        }
        label, input, select, textarea {
            display: block;
            margin-bottom: 10px;
            width: 100%;
        }
        .links {
            margin: 20px 0;
            display: flex;
        }
        .links a {
            margin-right: 10px;
        }

    </style>
</head>
<body>
<h1>Usermaven SDK Test</h1>

<div class="links">
    <a href="/examples/index.html">Home</a>
    <a href="/examples/form-tracking.html">Form Tracking</a>
</div>

<button id="trackEvent">Track Event</button>
<button id="identifyUser">Identify User</button>
<button class="your-class um-no-capture">
    This button will not be captured
</button>

<form id="testForm" data-um-form>
    <h2>Test Form</h2>
    <label for="name">Name:</label>
    <input type="text" id="name" name="name" required>

    <label for="email">Email:</label>
    <input type="email" id="email" name="email" required>

    <label for="password">Password:</label>
    <input type="password" id="password" name="password" required>

    <label for="age">Age:</label>
    <input type="number" id="age" name="age" min="18" max="120">

    <label for="country">Country:</label>
    <select id="country" name="country">
        <option value="">Select a country</option>
        <option value="us">United States</option>
        <option value="ca">Canada</option>
        <option value="uk">United Kingdom</option>
        <option value="au">Australia</option>
    </select>

    <label for="newsletter">
        <input type="checkbox" id="newsletter" name="newsletter">
        Subscribe to newsletter
    </label>

    <label for="comments">Comments:</label>
    <textarea id="comments" name="comments" rows="4"></textarea>

    <label for="sensitive" class="um-no-capture">
        <input type="text" id="sensitive" name="sensitive" class="um-no-capture">
        Sensitive field (will not be captured)
    </label>

    <button type="submit">Submit</button>
</form>

<!-- Load the SDK -->
<script src="/dist/lib.js"
        data-key="test-api-key"
        data-tracking-host="http://localhost:3000"
        data-log-level="debug"
        data-autocapture="true"
        data-form-tracking="true"
        data-auto-pageview="true"></script>

<!-- Load the test scripts -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Test event tracking
        document.getElementById('trackEvent').addEventListener('click', function() {
            usermaven('track', 'button_click', { buttonId: 'trackEvent' });
        });

        // Test user identification
        document.getElementById('identifyUser').addEventListener('click', function() {
            usermaven('id', { id: 'user123', email: 'test@example.com' });
        });

        // Test form submission
        // document.getElementById('testForm').addEventListener('submit', function(event) {
        //     event.preventDefault();
        //     console.log('Form submitted');
        // });
    });
</script>
</body>
</html>

</->

packages/javascript-sdk/examples/index.html
<->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Usermaven SDK Test</title>

    <style>
        .links {
            margin: 20px 0;
            display: flex;
        }
        .links a {
            margin-right: 10px;
        }

    </style>

</head>
<body>
<h1>Usermaven SDK Test</h1>
<div class="links">
    <a href="/examples/index.html">Home</a>
    <a href="/examples/form-tracking.html">Form Tracking</a>
</div>

<button id="trackEvent">Track Event</button>
<button id="identifyUser">Identify User</button>
<button class="your-class um-no-capture">
    This button will not be captured
</button>

<!-- Load the SDK -->
<script src="/dist/lib.js"
        data-key="test-api-key"
        data-tracking-host="http://localhost:3000"
        data-log-level="debug"
        data-autocapture="true"
        data-form-tracking="true"
        data-auto-pageview="true"></script>

<!-- Load the test scripts -->
<script src="./test.ts"></script>
</body>
</html>

</->

packages/javascript-sdk/examples/test.ts
<->
// Wait for the DOM to be fully loaded
document.addEventListener('DOMContentLoaded', () => {
    const checkUsermavenLoaded = () => {
        const usermaven = (window as any).usermaven;

        if (!usermaven) {
            console.log('Usermaven SDK not loaded yet, retrying in 100ms');
            setTimeout(checkUsermavenLoaded, 100);
            return;
        }

        console.log('Usermaven SDK loaded successfully', usermaven);

        // Test track event
        document.getElementById('trackEvent')?.addEventListener('click', () => {
            usermaven('track', 'button_click', { buttonId: 'trackEvent' });
            console.log('Track event sent');
        });

        // Test identify user
        document.getElementById('identifyUser')?.addEventListener('click', () => {
            usermaven('id', { id: 'user123', email: 'test@example.com' });
            console.log('User identified');
        });

        console.log('Usermaven SDK test scripts loaded');
    };

    checkUsermavenLoaded();
});

</->

packages/javascript-sdk/package.json
<->
{
  "name": "@usermaven/sdk-js",
  "version": "0.0.0",
  "description": "Usermaven JavaScript SDK",
  "main": "dist/lib.js",
  "module": "dist/usermaven.es.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "dev": "vite build --watch",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write \"src/**/*.ts\"",
    "mock": "wait-on dist/lib.js && node server/mockServer.js",
    "example:build": "tsc examples/test.ts --outDir examples",
    "example:serve": "wait-on dist/lib.js && vite --config vite.config.ts",
    "start": "concurrently \"npm run dev\" \"npm run example:serve\" \"npm run mock\" "
  },
  "keywords": [
    "usermaven",
    "analytics",
    "tracking"
  ],
  "license": "MIT",
  "devDependencies": {
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.5.0",
    "@types/node": "^18.15.11",
    "@typescript-eslint/eslint-plugin": "^5.57.1",
    "@typescript-eslint/parser": "^5.57.1",
    "@vitest/coverage-v8": "^2.1.2",
    "body-parser": "^1.20.3",
    "chalk": "^5.3.0",
    "colors": "^1.4.0",
    "concurrently": "^9.0.1",
    "cors": "^2.8.5",
    "eslint": "^8.37.0",
    "express": "^4.21.0",
    "jsdom": "^25.0.1",
    "morgan": "^1.10.0",
    "prettier": "^2.8.7",
    "typescript": "^5.0.3",
    "vite": "^5.4.8",
    "vite-plugin-dts": "^4.2.3",
    "vitest": "^2.1.2",
    "wait-on": "^8.0.1",
    "winston": "^3.14.2"
  }
}

</->

packages/javascript-sdk/server/mockServer.js
<->
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const morgan = require('morgan');
const winston = require('winston');
const colors = require('colors'); // Ensure you're using 'colors' and not 'colors/safe'
const fs = require('fs');

const app = express();
const port = 3000;
const logFilename = 'mock-server.log';

// Define an array of properties to highlight with their respective colors
const propertiesToHighlight = [
    { name: 'event_type', color: colors.green },
    { name: 'user_id', color: colors.blue },
    { name: 'email', color: colors.cyan },
    // Add more properties as needed
];

// Function to clear the log file
function clearLogFile() {
    fs.writeFileSync(logFilename, '');
    console.log(colors.yellow(`Cleared ${logFilename}`));
}

// Clear the log file on server start
clearLogFile();

// Define separate formats for console and file

// Console Format: Colorize specific properties
const consoleFormat = winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ level, message, timestamp }) => {
        let coloredMessage = message;

        // Iterate over each property to highlight
        propertiesToHighlight.forEach(({ name, color }) => {
            // Create a dynamic regex for each property
            const regex = new RegExp(`("${name}"\\s*:\\s*)"([^"]+)"`, 'g');
            // Replace the matched value with colored value
            coloredMessage = coloredMessage.replace(regex, (match, p1, p2) => {
                return `${p1}${color(`"${p2}"`)}`;
            });
        });

        return `${colors.gray(timestamp)} [${colors.blue(level)}]: ${coloredMessage}`;
    })
);

// File Format: Pretty-print JSON with indentation
const fileFormat = winston.format.combine(
    winston.format.timestamp(),
    winston.format.json({ space: 2 })
    // Alternatively, use the custom printf format as shown in Option B below
);

// Configure Winston logger with separate formats for console and file
const logger = winston.createLogger({
    level: 'info',
    transports: [
        new winston.transports.Console({
            format: consoleFormat
        }),
        new winston.transports.File({
            filename: logFilename,
            format: fileFormat
        })
    ]
});

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(morgan('dev'));


// Mock endpoint for event tracking
app.post('/api/v1/event', (req, res) => {
    // Serialize the request body to JSON with indentation
    const jsonString = JSON.stringify(req.body, null, 2);
    logger.info(`Received event:\n${jsonString}`);

    // Simulate processing delay
    setTimeout(() => {
        res.status(200).json({ success: true, message: 'Event received and processed' });
    }, 200);
});

app.post('/api/v1/s2s/event', (req, res) => {
    // Serialize the request body to JSON with indentation
    const jsonString = JSON.stringify(req.body, null, 2);
    logger.info(`Received server-side event:\n${jsonString}`);

    // Simulate processing delay
    setTimeout(() => {
        res.status(200).json({ success: true, message: 'Server Side Event received and processed' });
    }, 200);
});

// Error handling middleware
app.use((err, req, res, next) => {
    logger.error(`Error: ${err.message}`);
    res.status(500).json({ error: 'Internal server error' });
});

// Start the server
app.listen(port, () => {
    logger.info(`Mock server running at http://localhost:${port}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
    logger.info('SIGTERM signal received: closing HTTP server');
    app.close(() => {
        logger.info('HTTP server closed');
    });
});

</->

packages/javascript-sdk/src/core/client.ts
<->
import {Config, defaultConfig} from './config';
import {UserProps, EventPayload, Transport, CompanyProps, Policy} from './types';
import { Logger, getLogger } from '../utils/logger';
import { CookieManager } from '../utils/cookie';
import AutoCapture from '../tracking/autocapture';
import { PageviewTracking } from '../tracking/pageviews';
import { BeaconTransport } from '../transport/beacon';
import { FetchTransport } from '../transport/fetch';
import { XhrTransport } from '../transport/xhr';
import { LocalStoragePersistence } from '../persistence/local-storage';
import { MemoryPersistence } from '../persistence/memory';
import {generateId, isObject, isString, isValidEmail, parseQueryString} from '../utils/helpers';
import { RetryQueue } from '../utils/queue';
import {isWindowAvailable} from "../utils/common";
import {RageClick} from "../extensions/rage-click";
import {HttpsTransport} from "../transport/https";
import FormTracking from "../tracking/form-tracking";

export class UsermavenClient {
    private config: Config;
    private logger: Logger;
    private cookieManager?: CookieManager;
    private transport: Transport;
    private persistence: LocalStoragePersistence | MemoryPersistence;
    private autoCapture?: AutoCapture;
    private formTracking?: FormTracking;
    private pageviewTracking?: PageviewTracking;
    private retryQueue: RetryQueue;
    private anonymousId: string;
    private namespace: string;
    private rageClick?: RageClick;

    constructor(config: Config) {
        this.config = this.mergeConfig(config, defaultConfig);
        this.logger = getLogger();
        this.namespace = config.namespace || 'usermaven';
        this.transport = this.initializeTransport(this.config);
        this.persistence = this.initializePersistence();
        this.retryQueue = new RetryQueue(
            this.transport,
            this.config.maxSendAttempts || 3,
            this.config.minSendTimeout || 1000,
            10,
            500  // Reduced interval to .5 second
        );

        if (isWindowAvailable()) {
            this.initializeBrowserFeatures();
        }

        this.anonymousId = this.getOrCreateAnonymousId();


        this.logger.info(`Usermaven client initialized for namespace: ${this.namespace}`);
    }

    private initializeBrowserFeatures(): void {
        this.cookieManager = new CookieManager(this.config.cookieDomain);

        if (this.config.autocapture && AutoCapture.enabledForProject(this.config.key)) {
            this.autoCapture = new AutoCapture(this, this.config);
            this.autoCapture.init();
        }

        if (this.config.formTracking) {
            const trackingType = this.config.formTracking === true ? 'all' : this.config.formTracking;
            this.formTracking = FormTracking.getInstance(this, trackingType || "none", {
                trackFieldChanges: false,
            });
        }

        if (this.config.autoPageview) {
            this.pageviewTracking = new PageviewTracking(this);
        }

        if (this.config.crossDomainLinking) {
            this.manageCrossDomainLinking();
        }

        if (this.config.rageClick) {
            this.rageClick = new RageClick(this);
        }

        // Setup page leave tracking
        this.setupPageLeaveTracking();
    }

    /**
     * Recursively merge the provided configuration with the existing defaultConfig
     * @param config
     * @param defaultConfig
     */
    mergeConfig(config: Partial<Config>, defaultConfig: Partial<Config>): Config {
        // remove undefined values from the config
        const cleanConfig = JSON.parse(JSON.stringify(config));
        let newConfig = {...defaultConfig, ...cleanConfig};

        // recursively merge objects
        Object.keys(defaultConfig).forEach((key) => {
            if (isObject(defaultConfig[key as keyof Config])) {
                newConfig[key] = this.mergeConfig(config[key], defaultConfig[key]);
            }
        });


        return newConfig as Config;

    }

    public init(config: Config): void {
        this.config = { ...this.config, ...config };
        this.logger = getLogger();
        this.namespace = config.namespace || this.namespace;
        this.transport = this.initializeTransport(config);
        this.persistence = this.initializePersistence();
        this.retryQueue = new RetryQueue(
            this.transport,
            this.config.maxSendAttempts || 3,
            this.config.minSendTimeout || 1000,
            10,
            500  // Reduced interval to .5 second
        );

        if (isWindowAvailable()) {
            this.initializeBrowserFeatures();
        }

        this.anonymousId = this.getOrCreateAnonymousId();

        this.logger.info(`Usermaven client reinitialized for namespace: ${this.namespace}`);
    }

    private manageCrossDomainLinking(): void {
        if (!this.config.crossDomainLinking || !this.config.domains) {
            return;
        }

        const domains = this.config.domains.split(',').map(d => d.trim());
        // const cookieName = this.config.cookieName || `__eventn_id_${this.config.key}`;
        const cookieName = this.config.cookieName || `${this.namespace}_id_${this.config.key}`;


        document.addEventListener('click', (event) => {
            const target = this.findClosestLink(event.target as HTMLElement);
            if (!target) return;

            const href = target.getAttribute('href');
            if (!href || !href.startsWith('http')) return;

            const url = new URL(href);
            if (url.hostname === window.location.hostname) return;

            if (domains.includes(url.hostname)) {
                const cookie = this.cookieManager?.get(cookieName);
                if (cookie) {
                    url.searchParams.append('_um', cookie);
                    target.setAttribute('href', url.toString());
                }
            }
        });

        this.logger.debug('Cross-domain linking initialized');
    }

    private findClosestLink(element: HTMLElement | null): HTMLAnchorElement | null {
        while (element && element.tagName !== 'A') {
            element = element.parentElement;
        }
        return element as HTMLAnchorElement;
    }

    private initializeTransport(config: Config): Transport {
        if (!isWindowAvailable()) {
            return new HttpsTransport(config.trackingHost, config);
        }

        const isXhrAvailable = 'XMLHttpRequest' in window;
        const isFetchAvailable = typeof fetch !== 'undefined';
        const isBeaconAvailable = typeof navigator !== 'undefined' && 'sendBeacon' in navigator;

        if (config.useBeaconApi && isBeaconAvailable) {
            return new BeaconTransport(config.trackingHost, config);
        } else if (config.forceUseFetch && isFetchAvailable) {
            return new FetchTransport(config.trackingHost, config);
        } else if (isXhrAvailable) {
            return new XhrTransport(config.trackingHost, config);
        } else if (isFetchAvailable) {
            return new FetchTransport(config.trackingHost, config);
        } else {
            throw new Error('No suitable transport method available');
        }
    }


    private initializePersistence(): LocalStoragePersistence | MemoryPersistence {
        if (this.config.disableEventPersistence || !isWindowAvailable()) {
            return new MemoryPersistence();
        } else {
            return new LocalStoragePersistence(`${this.namespace}_${this.config.key}`);
        }
    }

    private getOrCreateAnonymousId(): string {
        if (!isWindowAvailable()) {
            return generateId(); // Use a function to generate a unique ID for server-side
        }

        if (this.config.privacyPolicy === 'strict' || this.config.cookiePolicy === 'strict') {
            return this.generateFingerprint();
        }

        const cookieName = this.config.cookieName || `${this.namespace}_id_${this.config.key}`;
        let id = this.cookieManager?.get(cookieName);

        if (!id) {
            if (this.config.crossDomainLinking) {
                const urlParams = new URLSearchParams(window.location.search);
                const queryId = urlParams.get('_um');

                const urlHash = window.location.hash.substring(1);
                const hashedValues = urlHash.split("~");
                const fragmentId = hashedValues.length > 1 ? hashedValues[1] : undefined;

                id = queryId || fragmentId || generateId();
            }

            if (!id) {
                id = generateId();
            }

            // Set cookie for 10 years
            const tenYearsInDays = 365 * 10;
            this.cookieManager?.set(cookieName, id, tenYearsInDays, true, false);
        }

        return id;
    }

    private generateFingerprint(): string {
        const userAgent = navigator.userAgent;
        const screenResolution = `${screen.width}x${screen.height}`;
        const colorDepth = screen.colorDepth;
        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        const fingerprintData = `${userAgent}|${screenResolution}|${colorDepth}|${timezone}`;
        return this.hashString(fingerprintData);
    }

    private hashString(str: string): string {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString(36);
    }

    public async id(userData: UserProps, doNotSendEvent: boolean = false): Promise<void> {
        if (!isObject(userData)) {
            throw new Error('User data must be an object');
        }

        if (userData.email && !isValidEmail(userData.email)) {
            throw new Error('Invalid email provided');
        }

        if (!userData.id || !isString(userData.id)) {
            throw new Error('User ID must be a string');
        }

        const userId = userData.id;
        this.persistence.set('userId', userId);
        this.persistence.set('userProps', userData);

        if (!doNotSendEvent) {
            const identifyPayload = {
                ...userData,
                anonymous_id: this.anonymousId,
            };

            await this.trackInternal('user_identify', identifyPayload);
        }

        this.logger.info('User identified:', userData);
    }

    public track(typeName: string, payload?: EventPayload, directSend: boolean = false): void {
        this.trackInternal(typeName, payload, directSend);
    }

    private trackInternal(typeName: string, payload?: EventPayload, directSend: boolean = false): void {
        if (!isString(typeName)) {
            throw new Error('Event name must be a string');
        }

        if (payload !== undefined && (typeof payload !== 'object' || payload === null || Array.isArray(payload))) {
            throw new Error('Event payload must be a non-null object and not an array');
        }

        const eventPayload = this.createEventPayload(typeName, payload);

        try {
            if (directSend) {
                this.transport.send(eventPayload);
                this.logger.debug(`Event sent: ${typeName}`, [eventPayload]);
                return;
            }
            this.retryQueue.add(eventPayload);
            this.logger.debug(`Event tracked: ${typeName}`, [eventPayload]);
        } catch (error) {
            this.logger.error(`Failed to track event: ${typeName}`, error);
            throw new Error(`Failed to track event: ${typeName}`);
        }
    }

    public rawTrack(payload: any): void {
        if (!isObject(payload)) {
            throw new Error('Event payload must be an object');
        }

        this.track('raw', payload);
    }


    public async group(props: CompanyProps, doNotSendEvent: boolean = false): Promise<void> {
        if (!isObject(props)) {
            throw new Error('Company properties must be an object');
        }

        if (!props.id || !props.name || !props.created_at) {
            throw new Error('Company properties must include id, name, and created_at');
        }

        this.persistence.set('companyProps', props);

        if (!doNotSendEvent) {
            await this.track('group', props);
        }

        this.logger.info('Company identified:', props);
    }

    private createEventPayload(eventName: string, eventProps?: EventPayload): any {
        const userProps = this.persistence.get('userProps') || {};
        const companyProps = this.persistence.get('companyProps') || {};
        const userId = this.persistence.get('userId');
        const globalProps = this.persistence.get('global_props') || {};
        const eventTypeProps = this.persistence.get(`props_${eventName}`) || {};

        const payload: any = {
            event_id: generateId(),
            user: {
                anonymous_id: this.anonymousId,
                id: userId,
                ...userProps
            },
            company: companyProps,
            ids: this.getThirdPartyIds(),
            utc_time: new Date().toISOString(),
            local_tz_offset: new Date().getTimezoneOffset(),
            api_key: this.config.key,
            src: "usermaven",
            event_type: eventName,
            event_attributes: eventProps || {},
            namespace: this.namespace,
            ...globalProps,
            ...eventTypeProps,
        };

        if (isWindowAvailable()) {
            payload.referer = document.referrer;
            payload.url = window.location.href;
            payload.page_title = document.title;
            payload.doc_path = window.location.pathname;
            payload.doc_host = window.location.hostname;
            payload.doc_search = window.location.search;
            payload.screen_resolution = `${window.screen.width}x${window.screen.height}`;
            payload.vp_size = `${window.innerWidth}x${window.innerHeight}`;
            payload.user_agent = navigator.userAgent;
            payload.user_language = navigator.language;
            payload.doc_encoding = document.characterSet;
            payload.utm = this.getUtmParams();
        }

        return payload;
    }

    public getCookie(name: string): string | null {
        return this.cookieManager?.get(name) || null;
    }

    private getThirdPartyIds(): Record<string, string> {
        const thirdPartyIds: Record<string, string> = {};
        if (isWindowAvailable()) {
            const fbpCookie = this.getCookie('_fbp');
            if (fbpCookie) {
                thirdPartyIds['fbp'] = fbpCookie;
            }
        }
        return thirdPartyIds;
    }

    private getUtmParams(): Record<string, string> {
        const utmParams: Record<string, string> = {};
        const queryParams = parseQueryString(window.location.search);
        const utmKeys = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'];

        utmKeys.forEach(key => {
            if (queryParams[key]) {
                utmParams[key.replace('utm_', '')] = queryParams[key];
            }
        });

        return utmParams;
    }

    public pageview(): void {
        if (isWindowAvailable()) {
            this.track('pageview', {
                url: window.location.href,
                referrer: document.referrer,
                title: document.title,
            }, true);
        } else {
            this.logger.warn('Pageview tracking is not available in server-side environments');
        }
    }

    private setupPageLeaveTracking(): void {
        if (!isWindowAvailable()) return;

        let isLeaving = false;

        const trackPageLeave = () => {
            if (!isLeaving) {
                isLeaving = true;
                this.track('$pageleave', {
                    url: window.location.href,
                    referrer: document.referrer,
                    title: document.title,
                });
            }
        };

        const isPageRefresh = (): boolean => {
            if ('PerformanceNavigationTiming' in window) {
                const perfEntries = performance.getEntriesByType('navigation');
                if (perfEntries.length > 0) {
                    const navEntry = perfEntries[0] as PerformanceNavigationTiming;
                    return navEntry.type === 'reload';
                }
            }
            // Fallback to the old API if PerformanceNavigationTiming is not supported
            return (performance.navigation && performance.navigation.type === 1);
        };

        // Check for refresh and route changes
        window.addEventListener('beforeunload', (event) => {
            if (!isPageRefresh()) {
                trackPageLeave();
            }
        });

        // Track on visibilitychange event (when the page becomes hidden)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden' && !isPageRefresh()) {
                trackPageLeave();
            }
        });

        // For Single Page Applications, track when the user navigates away
        const originalPushState = history.pushState;
        history.pushState = function() {
            trackPageLeave();
            return originalPushState.apply(this, arguments as any);
        };

        window.addEventListener('popstate', trackPageLeave);
    }

    public getConfig(): Config {
        return this.config;
    }

    public getLogger(): Logger {
        return this.logger;
    }

    public async reset(resetAnonId: boolean = false): Promise<void> {
        this.persistence.clear();

        if (resetAnonId && this.cookieManager) {
            const cookieName = this.config.cookieName || `${this.namespace}_id_${this.config.key}`;
            this.cookieManager.delete(cookieName);
            this.anonymousId = this.getOrCreateAnonymousId();
        }

        this.logger.info('core state reset', { resetAnonId, namespace: this.namespace });
    }

    public set(properties: Record<string, any>, opts?: { eventType?: string, persist?: boolean }): void {
        if (!isObject(properties)) {
            throw new Error('Properties must be an object');
        }

        const eventType = opts?.eventType;
        const persist = opts?.persist ?? true;

        if (eventType) {
            let props = this.persistence.get(`props_${eventType}`) || {};
            props = { ...props, ...properties };
            this.persistence.set(`props_${eventType}`, props);
        } else {
            let globalProps = this.persistence.get('global_props') || {};
            globalProps = { ...globalProps, ...properties };
            this.persistence.set('global_props', globalProps);
        }

        if (persist) {
            this.persistence.save();
        }

        this.logger.debug(`Properties set`, {
            properties,
            eventType: eventType || 'global',
            persist
        });
    }

    public unset(propertyName: string, options?: { eventType?: string, persist?: boolean }): void {
        const eventType = options?.eventType;
        const persist = options?.persist ?? true;

        if (eventType) {
            let props = this.persistence.get(`props_${eventType}`) || {};
            delete props[propertyName];
            this.persistence.set(`props_${eventType}`, props);
        } else {
            let props = this.persistence.get('global_props') || {};
            delete props[propertyName];
            this.persistence.set('global_props', props);
        }

        if (persist) {
            this.persistence.save();
        }

        this.logger.debug(`Property unset: ${propertyName}`, `Event type: ${eventType || 'global'}`);
    }

}

</->

packages/javascript-sdk/src/core/config.ts
<->
// src/core/config.ts

import { LogLevel } from '../utils/logger';

export type Policy = 'strict' | 'keep' | 'comply';

export interface Config {
    key: string;
    trackingHost: string;
    cookieDomain?: string;
    cookieName?: string;
    logLevel?: LogLevel;
    useBeaconApi?: boolean;
    forceUseFetch?: boolean;
    autocapture?: boolean;
    rageClick?: boolean;
    formTracking?: boolean | 'all' | 'tagged' | 'none';
    autoPageview?: boolean;
    disableEventPersistence?: boolean;
    gaHook?: boolean;
    segmentHook?: boolean;
    randomizeUrl?: boolean;
    capture3rdPartyCookies?: string[] | false;
    idMethod?: 'cookie' | 'localStorage';
    privacyPolicy?: 'strict';
    ipPolicy?: Policy;
    cookiePolicy?: Policy;
    customHeaders?: Record<string, string> | (() => Record<string, string>);
    minSendTimeout?: number;
    maxSendTimeout?: number;
    maxSendAttempts?: number;
    propertiesStringMaxLength?: number | null;
    propertyBlacklist?: string[];
    exclude?: string;
    namespace?: string;
    crossDomainLinking?: boolean;
    domains?: string;
    maskAllText?: boolean;
    maskAllElementAttributes?: boolean;
}

export const defaultConfig: Partial<Config> = {
    logLevel: LogLevel.WARN,
    useBeaconApi: false,
    forceUseFetch: false,
    trackingHost: 't.usermaven.com',
    autocapture: false,
    rageClick: false,
    formTracking: false,
    autoPageview: false,
    disableEventPersistence: false,
    gaHook: false,
    segmentHook: false,
    randomizeUrl: false,
    capture3rdPartyCookies: ['_ga', '_fbp', '_ym_uid', 'ajs_user_id', 'ajs_anonymous_id'],
    idMethod: 'cookie',
    ipPolicy: 'keep',
    cookiePolicy: 'keep',
    minSendTimeout: 0,
    maxSendTimeout: 2000,
    maxSendAttempts: 4,
    propertiesStringMaxLength: null,
    propertyBlacklist: [],
    crossDomainLinking: true,
    maskAllText: false,
    maskAllElementAttributes: false,
};

</->

packages/javascript-sdk/src/core/types.ts
<->
export interface EventPayload {
    [key: string]: any;
}

export interface UserProps extends EventPayload {
    id?: string;
    email?: string;
}


export interface Transport {
    send(payload: any): Promise<void>;
}

export interface UserProps {
    id?: string;
    email?: string;
    [key: string]: any;
}


export type Policy = 'strict' | 'keep' | 'comply';

export interface CompanyProps {
    id: string;
    name: string;
    created_at: string;
    [key: string]: any;
}

/**
 * Environment where the event have happened.
 */
export type ClientProperties = {
    screen_resolution: string        //screen resolution
    user_agent: string               //user
    referer: string                  //document referer
    url: string                      //current url
    page_title: string               //page title
                                     //see UTM_TYPES for all supported utm tags
    doc_path: string                 //document path
    doc_host: string                 //document host
    doc_search: string               //document search string

    vp_size: string                  //viewport size
    user_language: string            //user language
    doc_encoding: string
}

</->

packages/javascript-sdk/src/extensions/rage-click.ts
<->
import { UsermavenClient } from '../core/client';
import { _safewrap_instance_methods } from '../utils/common';

export class RageClick {
    private client: UsermavenClient;
    private clicks: { x: number; y: number; timestamp: number }[] = [];
    private threshold = 3;
    private timeWindow = 2000; // 2 seconds
    private distanceThreshold = 30;

    constructor(client: UsermavenClient) {
        this.client = client;
        this.initializeEventListener();
        _safewrap_instance_methods(this);
    }

    private initializeEventListener(): void {
        document.addEventListener('click', this.handleClick.bind(this));
    }

    private handleClick(event: MouseEvent): void {
        const element = event.target as Element;
        if (this.shouldCaptureElement(element)) {
            this.click(event.clientX, event.clientY, Date.now());
        }
    }

    private shouldCaptureElement(element: Element): boolean {
        return !element.closest('.um-no-capture');
    }

    public click(x: number, y: number, timestamp: number): void {
        const click = { x, y, timestamp };
        this.clicks.push(click);

        // Remove old clicks outside the time window
        this.clicks = this.clicks.filter(c => timestamp - c.timestamp < this.timeWindow);

        if (this.clicks.length >= this.threshold) {
            this.checkRageClick();
        }
    }

    private checkRageClick(): void {
        const firstClick = this.clicks[0];
        const lastClick = this.clicks[this.clicks.length - 1];
        const totalTime = (lastClick.timestamp - firstClick.timestamp) / 1000; // in seconds

        const isRageClick = this.clicks.every((c, i) => {
            if (i === 0) return true;
            const prev = this.clicks[i - 1];
            const distance = Math.sqrt(Math.pow(c.x - prev.x, 2) + Math.pow(c.y - prev.y, 2));
            return distance < this.distanceThreshold;
        });

        if (isRageClick) {
            this.sendRageClickEvent(totalTime);
        }
    }

    private sendRageClickEvent(totalTime: number): void {
        const lastClick = this.clicks[this.clicks.length - 1];
        const element = document.elementFromPoint(lastClick.x, lastClick.y);

        if (element) {
            this.client.track('$rage_click', {
                no_of_clicks: this.clicks.length,
                time: totalTime.toFixed(2)
            });
        }

        this.clicks = []; // Reset clicks after sending the event
    }
}

</->

packages/javascript-sdk/src/extensions/scroll-depth.ts
<->
import { UsermavenClient } from '../core/client';
import { debounce } from '../utils/helpers';

export class ScrollDepth {
    private client: UsermavenClient;
    private maxScrollDepth: number = 0;
    private milestones: number[] = [25, 50, 75, 90];
    private lastScrollDepth: number = 0;
    private documentElement: HTMLElement;
    private debouncedHandleScroll: () => void;

    constructor(client: UsermavenClient) {
        this.client = client;
        this.documentElement = document.documentElement;
        this.debouncedHandleScroll = debounce(this.handleScroll.bind(this), 250);
        this.initializeEventListener();
    }

    private initializeEventListener(): void {
        window.addEventListener('scroll', this.debouncedHandleScroll);
    }

    public track(): void {
        const scrollDepth = this.getScrollDepth();

        if (scrollDepth > this.lastScrollDepth) {
            this.lastScrollDepth = scrollDepth;
            this.checkMilestones(scrollDepth);
        }
    }

    public send(eventType = "$scroll"): void {
        const props = {
            percent: this.lastScrollDepth,
            window_height: this.getWindowHeight(),
            document_height: this.getDocumentHeight(),
            scroll_distance: this.getScrollDistance()
        };

        this.client.track(eventType, props);
    }

    private handleScroll(): void {
        this.track();
    }

    private getScrollDepth(): number {
        const windowHeight = this.getWindowHeight();
        const docHeight = this.getDocumentHeight();
        const scrollTop = this.getScrollDistance();
        const trackLength = docHeight - windowHeight;

        return Math.min(100, Math.floor(scrollTop / trackLength * 100));
    }

    private getWindowHeight(): number {
        return window.innerHeight || this.documentElement.clientHeight || document.body.clientHeight || 0;
    }

    private getDocumentHeight(): number {
        return Math.max(
            document.body.scrollHeight || 0,
            this.documentElement.scrollHeight || 0,
            document.body.offsetHeight || 0,
            this.documentElement.offsetHeight || 0,
            document.body.clientHeight || 0,
            this.documentElement.clientHeight || 0
        );
    }

    private getScrollDistance(): number {
        return window.pageYOffset || this.documentElement.scrollTop || document.body.scrollTop || 0;
    }

    private checkMilestones(scrollPercentage: number): void {
        const reachedMilestones = this.milestones.filter(milestone => scrollPercentage >= milestone);

        reachedMilestones.forEach(milestone => {
            this.send();
            this.milestones = this.milestones.filter(m => m !== milestone);
        });
    }
}

</->

packages/javascript-sdk/src/global.d.ts
<->
declare global {
    var module: {
        exports: any;
    };
}

export {};

</->

packages/javascript-sdk/src/index.ts
<->
import { UsermavenClient } from './core/client';
import { defaultConfig } from './core/config';
import type { Config } from './core/config';
import { LogLevel } from './utils/logger';
import type { UserProps, EventPayload, ClientProperties } from './core/types';
import {parseLogLevel} from "./utils/helpers";
import {isWindowAvailable} from "./utils/common";

function usermavenClient(config: Partial<Config>): UsermavenClient {
    const cleanConfig = JSON.parse(JSON.stringify(config));
    const mergedConfig: Config = { ...defaultConfig, ...cleanConfig } as Config;

    if (!mergedConfig.key) {
        console.error(mergedConfig);
        console.error(config);
        throw new Error('API key is required!');
    }

    if (!mergedConfig.trackingHost) {
        throw new Error('Tracking host is required!');
    }

    return new UsermavenClient(mergedConfig);
}

function initFromScript(script: HTMLScriptElement) {

    const config: Partial<Config> = {
        key: script.getAttribute('data-key') || undefined,
        trackingHost: script.getAttribute('data-tracking-host') || 'https://events.usermaven.com',
        logLevel: parseLogLevel(script.getAttribute('data-log-level')),
        autocapture: script.getAttribute('data-autocapture') === 'true',
        formTracking: script.getAttribute('data-form-tracking') === 'true' ? 'all' : false,
        autoPageview: script.getAttribute('data-auto-pageview') === 'true',
        useBeaconApi: script.getAttribute('data-use-beacon-api') === 'true',
        forceUseFetch: script.getAttribute('data-force-use-fetch') === 'true',
        gaHook: script.getAttribute('data-ga-hook') === 'true',
        segmentHook: script.getAttribute('data-segment-hook') === 'true',
        randomizeUrl: script.getAttribute('data-randomize-url') === 'true',
        capture3rdPartyCookies: script.getAttribute('data-capture-3rd-party-cookies') === 'false' ? false : undefined,
        idMethod: (script.getAttribute('data-id-method') as 'cookie' | 'localStorage') || undefined,
        privacyPolicy: script.getAttribute('data-privacy-policy') === 'strict' ? 'strict' : undefined,
        ipPolicy: (script.getAttribute('data-ip-policy') as Config['ipPolicy']) || undefined,
        cookiePolicy: (script.getAttribute('data-cookie-policy') as Config['cookiePolicy']) || undefined,
        minSendTimeout: parseInt(script.getAttribute('data-min-send-timeout') || '', 10) || undefined,
        maxSendTimeout: parseInt(script.getAttribute('data-max-send-timeout') || '', 10) || undefined,
        maxSendAttempts: parseInt(script.getAttribute('data-max-send-attempts') || '', 10) || undefined,
        propertiesStringMaxLength: parseInt(script.getAttribute('data-properties-string-max-length') || '', 10) || null,
        propertyBlacklist: script.getAttribute('data-property-blacklist')?.split(',') || undefined,
        exclude: script.getAttribute('data-exclude') || undefined,
        namespace: script.getAttribute('data-namespace') || undefined,
        crossDomainLinking: script.getAttribute('data-cross-domain-linking') !== 'false',
        domains: script.getAttribute('data-domains') || undefined,
        maskAllText: script.getAttribute('data-mask-all-text') === 'true',
        maskAllElementAttributes: script.getAttribute('data-mask-all-element-attributes') === 'true',
    };


    const client = usermavenClient(config);
    const namespace = config.namespace || 'usermaven';

    // if browser environment, send the first pageview
    if (isWindowAvailable()) {
        client.pageview();
    }

    initializeNamespacedClient(namespace, client);
}

function initializeNamespacedClient(namespace: string, client: UsermavenClient) {
    let isReady = false;
    const queue: any[][] = [];
    const onLoadCallbacks: (() => void)[] = [];

    function processQueue() {
        while (queue.length > 0) {
            const item = queue.shift();
            if (item) {
                (window as any)[namespace].apply(null, item);
            }
        }
    }

    function executeOnLoadCallbacks() {
        onLoadCallbacks.forEach(callback => callback());
        onLoadCallbacks.length = 0;
    }

    (window as any)[namespace] = function(...args: any[]) {
        const method = args[0];

        if (method === 'onLoad') {
            if (typeof args[1] === 'function') {
                if (isReady) {
                    args[1]();
                } else {
                    onLoadCallbacks.push(args[1]);
                }
            }
            return;
        }

        if (!isReady) {
            queue.push(args);
            return;
        }

        if (typeof client[method] === 'function') {
            return client[method].apply(client, args.slice(1));
        } else {
            console.error(`Method ${method} not found on UsermavenClient`);
        }
    };

    // Initialize queue processing
    const queueName = `${namespace}Q`;
    const existingQueue = (window as any)[queueName] || [];
    (window as any)[queueName] = existingQueue;

    existingQueue.push = function(...args: any[]) {
        (window as any)[namespace].apply(null, args);
        return Array.prototype.push.apply(this, args);
    };

    // Set core as ready and process any queued items
    setTimeout(() => {
        isReady = true;
        processQueue();
        executeOnLoadCallbacks();
        console.log(`Usermaven client for namespace ${namespace} is ready`);
    }, 0);

    // Process any existing queue items
    while (existingQueue.length > 0) {
        const item = existingQueue.shift();
        if (item) {
            queue.push(item);
        }
    }
}

if (isWindowAvailable()) {
    // Browser-specific initialization
// Wrap the initialization in an IIFE
    (function (document, window) {
        // Capture the current scripts
        const currentScript = document.currentScript as HTMLScriptElement;

        function initialize() {
            if (currentScript && currentScript.src.includes('lib.js')) {
                initFromScript(currentScript);
            }
        }

        // Check if we're in a browser environment
        if (typeof window !== 'undefined') {
            // If the scripts is loaded with defer or async, we need to wait for the DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        }
    })(document, window);
}

export { usermavenClient, UsermavenClient, Config as UsermavenOptions, UserProps, EventPayload, LogLevel, ClientProperties };

</->

packages/javascript-sdk/src/persistence/local-storage.ts
<->
import {getLogger} from "../utils/logger";

export class LocalStoragePersistence {
    private storage: Record<string, any> = {};
    private prefix: string;

    constructor(apiKey: string) {
        this.prefix = `usermaven_${apiKey}_`;
        this.load();
    }

    set(key: string, value: any): void {
        this.storage[key] = value;
        this.save();
    }

    get(key: string): any {
        return this.storage[key];
    }

    remove(key: string): void {
        delete this.storage[key];
        this.save();
    }

    clear(): void {
        this.storage = {};
        this.save();
    }

    save(): void {
        try {
            localStorage.setItem(this.prefix + 'data', JSON.stringify(this.storage));
        } catch (error) {
            getLogger().error('Error saving to localStorage:', error);
        }
    }

    private load(): void {
        try {
            const data = localStorage.getItem(this.prefix + 'data');
            if (data) {
                this.storage = JSON.parse(data);
            }
        } catch (error) {
            getLogger().error('Error loading from localStorage:', error);
        }
    }
}

</->

packages/javascript-sdk/src/persistence/memory.ts
<->
// src/persistence/memory.ts

export class MemoryPersistence {
    private storage: Record<string, any> = {};

    set(key: string, value: any): void {
        this.storage[key] = value;
    }

    get(key: string): any {
        return this.storage[key];
    }

    remove(key: string): void {
        delete this.storage[key];
    }

    save(): void {
        // No-op for memory persistence
    }

    clear(): void {
        this.storage = {};
    }
}

</->

packages/javascript-sdk/src/tracking/autocapture.ts
<->
import {
    _bind_instance_methods,
    _each,
    _extend,
    _includes,
    _isFunction,
    _isUndefined,
    _register_event,
    _safewrap_instance_methods,
    _trim
} from '../utils/common';
import {
    getClassName,
    getSafeText,
    isElementNode,
    isSensitiveElement,
    isTag,
    isTextNode,
    shouldCaptureDomEvent,
    shouldCaptureElement,
    shouldCaptureValue,
    usefulElements,
    isAngularStyleAttr,
    isDocumentFragment,
} from '../utils/autocapture-utils';
import { getLogger } from '../utils/logger';
import {ScrollDepth} from "../extensions/scroll-depth";
import {UsermavenClient} from "@/core/client";
import {Config} from "../core/config";
import {EventPayload} from "../core/types";

class AutoCapture {
    private client: UsermavenClient;
    private options: Config;
    private scrollDepth: ScrollDepth | null = null;

    // Constants for custom attributes
    private static readonly FORCE_CAPTURE_ATTR = 'data-um-force-capture';
    private static readonly PREVENT_CAPTURE_ATTR = 'data-um-no-capture';

    constructor(client: UsermavenClient, options: Config) {
        this.client = client;
        this.options = options;
        this.scrollDepth = new ScrollDepth(client);
        _bind_instance_methods(this);
        _safewrap_instance_methods(this);
    }

    public init(): void {
        if (!(document && document.body)) {
            getLogger().debug('Document not ready yet, trying again in 500 milliseconds...');
            setTimeout(() => this.init(), 500);
            return;
        }

        this.addDomEventHandlers();
    }

    private addDomEventHandlers(): void {
        const handler = (e: Event) => {
            e = e || window.event;
            this.captureEvent(e);
        };

        _register_event(document, 'submit', handler, false, true);
        _register_event(document, 'change', handler, false, true);
        _register_event(document, 'click', handler, false, true);
        _register_event(document, 'visibilitychange', handler, false, true);
        _register_event(document, 'scroll', handler, false, true);
        _register_event(window, 'popstate', handler, false, true);
    }

    private isPageRefresh(): boolean {
        if ('PerformanceNavigationTiming' in window) {
            const perfEntries = performance.getEntriesByType('navigation');
            if (perfEntries.length > 0) {
                const navEntry = perfEntries[0] as PerformanceNavigationTiming;
                return navEntry.type === 'reload';
            }
        }
        // Fallback to the old API if PerformanceNavigationTiming is not supported
        return (performance.navigation && performance.navigation.type === 1);
    }

    private captureEvent(e: Event): boolean | void {
        let target = this.getEventTarget(e);
        if (isTextNode(target)) {
            target = (target.parentNode || null) as Element | null;
        }

        if (e.type === 'scroll') {
            this.scrollDepth?.track();
            return true;
        }

        if ((e.type === 'visibilitychange' && document.visibilityState === 'hidden') || e.type === 'popstate') {
            if (!this.isPageRefresh()) {
                this.scrollDepth?.send();
            }
            return true;
        }

        if (target && this.shouldCaptureElement(target, e)) {
            const targetElementList = this.getElementList(target);
            const elementsJson = this.getElementsJson(targetElementList, e);

            const props = _extend(
                this.getDefaultProperties(e.type),
                {
                    $elements: elementsJson,
                }
            );

            this.client.track('$autocapture', props);
            return true;
        }
    }

    private shouldCaptureElement(element: Element, event: Event): boolean {
        // Check for force capture attribute
        if (element.hasAttribute(AutoCapture.FORCE_CAPTURE_ATTR)) {
            return true;
        }

        // Check for prevent capture attribute
        if (element.hasAttribute(AutoCapture.PREVENT_CAPTURE_ATTR)) {
            return false;
        }

        // Default capture logic
        return shouldCaptureDomEvent(element, event);
    }

    private getEventTarget(e: Event): Element | null {
        if (typeof e.target === 'undefined') {
            return (e.srcElement as Element) || null;
        } else {
            if ((e.target as HTMLElement)?.shadowRoot) {
                return (e.composedPath()[0] as Element) || null;
            }
            return (e.target as Element) || null;
        }
    }

    private getElementList(target: Element): Element[] {
        const elementList: Element[] = [target];
        let curEl: Element | ParentNode = target;
        while (curEl.parentNode && !isTag(curEl as Element, 'body')) {
            if (isDocumentFragment(curEl.parentNode)) {
                elementList.push((curEl.parentNode as any).host);
                curEl = (curEl.parentNode as any).host;
            } else {
                elementList.push(curEl.parentNode as Element);
                curEl = curEl.parentNode;
            }
        }
        return elementList;
    }

    private getElementsJson(targetElementList: Element[], e: Event): any[] {
        const elementsJson: any[] = [];
        let href;

        _each(targetElementList, (el) => {
            if (isTag(el, 'a')) {
                href = el.getAttribute('href');
                href = shouldCaptureElement(el) && shouldCaptureValue(href) && href;
            }

            elementsJson.push(this.getPropertiesFromElement(el));
        });

        if (!this.options.maskAllText) {
            elementsJson[0]['$el_text'] = this.sanitizeText(getSafeText(targetElementList[0]));
        }

        if (href) {
            elementsJson[0]['attr__href'] = this.sanitizeUrl(href);
        }

        return elementsJson;
    }

    private getPropertiesFromElement(element: Element): any {
        const props: any = {
            tag_name: element.tagName.toLowerCase(),
        };

        if (usefulElements.indexOf(props.tag_name) > -1 && !this.options.maskAllText) {
            props['$el_text'] = this.sanitizeText(getSafeText(element));
        }

        const classes = getClassName(element);
        if (classes.length > 0) {
            props['classes'] = classes.split(' ').filter((c) => c !== '');
        }

        _each(element.attributes, (attr: Attr) => {
            if (isSensitiveElement(element) && ['name', 'id', 'class'].indexOf(attr.name) === -1) return;

            if (!this.options.maskAllElementAttributes && shouldCaptureValue(attr.value) && !isAngularStyleAttr(attr.name)) {
                props['attr__' + attr.name] = this.sanitizeAttributeValue(attr.name, attr.value);
            }
        });

        let nthChild = 1;
        let nthOfType = 1;
        let currentElem: Element | null = element;
        while ((currentElem = this.previousElementSibling(currentElem))) {
            nthChild++;
            if (currentElem.tagName === element.tagName) {
                nthOfType++;
            }
        }
        props['nth_child'] = nthChild;
        props['nth_of_type'] = nthOfType;

        return props;
    }

    private previousElementSibling(el: Element): Element | null {
        if (el.previousElementSibling) {
            return el.previousElementSibling;
        } else {
            do {
                el = el.previousSibling as Element;
            } while (el && !isElementNode(el));
            return el;
        }
    }

    private getDefaultProperties(eventType: string): EventPayload {
        return {
            $event_type: eventType,
            $ce_version: 1,
        };
    }

    // Input sanitization and XSS prevention methods

    private sanitizeText(text: string): string {
        // Remove any HTML tags
        text = text.replace(/<[^>]*>/g, '');

        // Encode special characters
        text = this.encodeHtml(text);

        // Truncate long strings
        const maxLength = this.options.propertiesStringMaxLength || 255;
        if (text.length > maxLength) {
            text = text.substring(0, maxLength) + '...';
        }

        return text;
    }

    private sanitizeUrl(url: string): string {
        try {
            // Parse the URL
            const parsedUrl = new URL(url);

            // Only allow http and https protocols
            if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
                return '';
            }

            // Encode the URL components
            return encodeURI(parsedUrl.toString());
        } catch (e) {
            // If URL parsing fails, return an empty string
            return '';
        }
    }

    private sanitizeAttributeValue(name: string, value: string): string {
        // Sanitize based on attribute name
        switch (name.toLowerCase()) {
            case 'href':
            case 'src':
                return this.sanitizeUrl(value);
            default:
                return this.encodeHtml(value);
        }
    }

    private encodeHtml(str: string): string {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    public static enabledForProject(token: string, numBuckets: number = 10, numEnabledBuckets: number = 10): boolean {
        if (!token) {
            return false;
        }
        let charCodeSum = 0;
        for (let i = 0; i < token.length; i++) {
            charCodeSum += token.charCodeAt(i);
        }
        return charCodeSum % numBuckets < numEnabledBuckets;
    }

    public static isBrowserSupported(): boolean {
        return _isFunction(document.querySelectorAll);
    }
}

export default AutoCapture;

</->

packages/javascript-sdk/src/tracking/form-tracking.ts
<->

import {UsermavenClient} from "../core/client";
import {_cleanObject} from "../utils/common";

export default class FormTracking {
    private instance: UsermavenClient;
    private formElements?: NodeListOf<HTMLFormElement>;
    private trackingType: 'all' | 'tagged' | 'none';
    private options: FormTrackingOptions;

    // Singleton instance
    private static instance: FormTracking;

    private constructor(instance: UsermavenClient, trackingType: 'all' | 'tagged' | 'none' = 'all', options: FormTrackingOptions = {}) {
        this.instance = instance;
        this.trackingType = trackingType;
        this.options = options;

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', this.initialize.bind(this));
        } else {
            this.initialize();
        }
    }

    private initialize(): void {
        if (this.trackingType === 'none') {
            return;
        }

        this.setupFormTracking();
    }

    private setupFormTracking(): void {
        this.formElements = this.trackingType === 'tagged'
            ? document.querySelectorAll('form[data-um-form]')
            : document.querySelectorAll('form');

        this.formElements?.forEach(form => {
            form.addEventListener('submit', this.handleFormSubmit.bind(this));
        });
    }

    private handleFormSubmit(event: Event): void {
        const form = event.target as HTMLFormElement;
        const props = this._getFormDetails(form);

        this.instance.track('$form', _cleanObject(props));

        if (this.options.trackFieldChanges) {
            this.trackFieldChanges(form);
        }
    }

    private trackFieldChanges(form: HTMLFormElement): void {
        const fields = form.querySelectorAll('input, select, textarea');
        fields.forEach(field => {
            field.addEventListener('change', (event) => {
                const fieldProps = this._getFieldProps(event.target as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, 0);
                this.instance.track('$form_field_change', _cleanObject(fieldProps));
            });
        });
    }

    public static getInstance(instance: UsermavenClient, trackingType: 'all' | 'tagged' | 'none' = 'all', options: FormTrackingOptions = {}): FormTracking {
        if (!FormTracking.instance) {
            FormTracking.instance = new FormTracking(instance, trackingType, options);
        }
        return FormTracking.instance;
    }

    private _getFormDetails(form: HTMLFormElement) {
        const formDetails = {
            form_id: form.id,
            form_name: form.name || '',
            form_action: form.action,
            form_method: form.method,
            form_class: form.className,
            form_attributes: this._getElementAttributes(form),
        };

        const formFields = form.querySelectorAll('input, select, textarea') as NodeListOf<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>;
        const filteredFormFields = Array.from(formFields).filter(field => !field.classList.contains('um-no-capture'));

        filteredFormFields.forEach((field: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, index: number) => {
            const fieldProps = this._getFieldProps(field, index);
            Object.assign(formDetails, fieldProps);
        });

        return formDetails;
    }

    private _getFieldProps(field: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, index: number) {
        const fieldDataAttributes = Object.keys(field.dataset).length ? JSON.stringify(field.dataset) : undefined;
        const safeValue = this.getSafeText(field);

        return {
            [`field_${index + 1}_tag`]: field.tagName.toLowerCase(),
            [`field_${index + 1}_type`]: field instanceof HTMLInputElement ? field.type : undefined,
            [`field_${index + 1}_data_attributes`]: fieldDataAttributes,
            [`field_${index + 1}_id`]: field.id,
            [`field_${index + 1}_value`]: safeValue,
            [`field_${index + 1}_class`]: field.className,
            [`field_${index + 1}_name`]: field.name,
            [`field_${index + 1}_attributes`]: this._getElementAttributes(field),
        };
    }

    private _getElementAttributes(element: Element): Record<string, string> {
        const attributes: Record<string, string> = {};
        for (let i = 0; i < element.attributes.length; i++) {
            const attr = element.attributes[i];
            if (attr.name !== 'value' && !attr.name.startsWith('data-')) {
                attributes[attr.name] = attr.value;
            }
        }
        return attributes;
    }

    private getSafeText(element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | Node): string {
        let safeText = '';

        if ('value' in element && element.type !== "password") {
            safeText = element.value;
        } else if (element.hasChildNodes()) {
            const textNodes = Array.from(element.childNodes).filter(
                node => node.nodeType === Node.TEXT_NODE
            );
            safeText = textNodes.map(node => node.textContent).join('');
        } else {
            safeText = element.textContent || '';
        }

        return this._scrubPotentiallySensitiveValues(safeText);
    }

    private _scrubPotentiallySensitiveValues(text: string): string {
        if (!this._shouldCaptureValue(text)) {
            return '<redacted>';
        }
        return text;
    }

    private _shouldCaptureValue(value: string): boolean {
        if (this._isNullish(value)) {
            return false;
        }

        if (this._isString(value)) {
            value = this._trim(value);

            const ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;
            if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {
                return false;
            }

            const ssnRegex = /(^\d{3}-?\d{2}-?\d{4}$)/;
            if (ssnRegex.test(value)) {
                return false;
            }

            // Add more sensitive data patterns here if needed
        }

        return true;
    }

    private _isNullish(value: any): boolean {
        return value === null || value === undefined;
    }

    private _isString(value: any): boolean {
        return typeof value === 'string' || value instanceof String;
    }

    private _trim(value: string): string {
        return value.trim().replace(/^\s+|\s+$/g, '');
    }
}

interface FormTrackingOptions {
    trackFieldChanges?: boolean;
    // Add more options as needed
}

</->

packages/javascript-sdk/src/tracking/pageviews.ts
<->
import { UsermavenClient } from '../core/client';

export class PageviewTracking {
    private client: UsermavenClient;
    private lastPageUrl: string;

    constructor(client: UsermavenClient) {
        this.client = client;
        this.lastPageUrl = window.location.href;
        this.trackInitialPageview();
        this.initializePageviewTracking();
    }

    private trackInitialPageview(): void {
        this.trackPageview();
    }

    private initializePageviewTracking(): void {
        // Handle browser back/forward buttons
        window.addEventListener('popstate', this.handlePageview.bind(this));

        // Handle programmatic navigation in SPAs
        const originalPushState = history.pushState;
        history.pushState = (...args: Parameters<typeof history.pushState>) => {
            originalPushState.apply(history, args);
            this.handlePageview();
        };

        // Handle hash changes (for SPAs that use hash-based routing)
        window.addEventListener('hashchange', this.handlePageview.bind(this));

        // Periodically check for changes (catches any missed navigations)
        setInterval(this.checkForUrlChange.bind(this), 1000);
    }

    private handlePageview(): void {
        this.trackPageview();
    }

    private checkForUrlChange(): void {
        if (window.location.href !== this.lastPageUrl) {
            this.trackPageview();
        }
    }

    private trackPageview(): void {
        const currentUrl = window.location.href;
        if (currentUrl !== this.lastPageUrl) {
            this.lastPageUrl = currentUrl;
            this.client.track('pageview', {
                url: currentUrl,
                referrer: document.referrer,
                title: document.title
            });
        }
    }
}

</->

packages/javascript-sdk/src/transport/beacon.ts
<->
import { Transport } from '../core/types';
import { getLogger } from '../utils/logger';
import { isWindowAvailable, generateRandom } from "../utils/common";
import { Config } from '@/core/config';

export class BeaconTransport implements Transport {
    private config: Config;

    constructor(private trackingHost: string, config: Config) {
        this.config = config;
    }

    async send(payloads: any[]): Promise<void> {
        const apiKey = this.config.key;
        const url = this.constructUrl(apiKey);
        const blob = new Blob([JSON.stringify(payloads)], { type: 'application/json' });

        if (navigator.sendBeacon(url, blob)) {
            getLogger().debug(`Successfully queued ${payloads.length} event(s) via Beacon API`);
        } else {
            throw new Error("Failed to queue events via Beacon API");
        }

        // Note: Beacon API doesn't provide a way to handle the response,
        // so we can't implement post-handling here.
    }

    private constructUrl(apiKey: string): string {
        const cookiePolicy = this.config.cookiePolicy !== "keep" ? `&cookie_policy=${this.config.cookiePolicy}` : "";
        const ipPolicy = this.config.ipPolicy !== "keep" ? `&ip_policy=${this.config.ipPolicy}` : "";
        const urlPrefix = isWindowAvailable() ? "/api/v1/event" : "/api/v1/s2s/event";

        if (this.config.randomizeUrl) {
            return `${this.trackingHost}/api.${generateRandom()}?p_${generateRandom()}=${apiKey}${cookiePolicy}${ipPolicy}`;
        } else {
            return `${this.trackingHost}${urlPrefix}?token=${apiKey}${cookiePolicy}${ipPolicy}`;
        }
    }

    // Note: Beacon API doesn't support custom headers, so we can't use them here.
    // If custom headers are crucial, you might want to fall back to XHR or Fetch in those cases.
}

</->

packages/javascript-sdk/src/transport/fetch.ts
<->
import { Transport } from '../core/types';
import { getLogger } from '../utils/logger';
import { isWindowAvailable, generateRandom } from "../utils/common";
import { Config } from '@/core/config';

export class FetchTransport implements Transport {
    private config: Config;

    constructor(private trackingHost: string, config: Config) {
        this.config = config;
    }

    async send(payloads: any[]): Promise<void> {
        const apiKey = this.config.key;
        const url = this.constructUrl(apiKey);
        const body = JSON.stringify(payloads);

        const headers = {
            'Content-Type': 'application/json',
            ...this.getCustomHeaders()
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body,
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        getLogger().debug(`Successfully sent ${payloads.length} event(s)`);

        // Post-handling
        this.postHandle(response.status, await response.text());
    }

    private constructUrl(apiKey: string): string {
        const cookiePolicy = this.config.cookiePolicy !== "keep" ? `&cookie_policy=${this.config.cookiePolicy}` : "";
        const ipPolicy = this.config.ipPolicy !== "keep" ? `&ip_policy=${this.config.ipPolicy}` : "";
        const urlPrefix = isWindowAvailable() ? "/api/v1/event" : "/api/v1/s2s/event";

        if (this.config.randomizeUrl) {
            return `${this.trackingHost}/api.${generateRandom()}?p_${generateRandom()}=${apiKey}${cookiePolicy}${ipPolicy}`;
        } else {
            return `${this.trackingHost}${urlPrefix}?token=${apiKey}${cookiePolicy}${ipPolicy}`;
        }
    }

    private getCustomHeaders(): Record<string, string> {
        if (typeof this.config.customHeaders === 'function') {
            return this.config.customHeaders();
        } else if (this.config.customHeaders) {
            return this.config.customHeaders;
        }
        return {};
    }

    private postHandle(code: number, body: string): void {
        // Implement post-handling logic if needed
        getLogger().debug(`Response received. Status: ${code}, Body: ${body}`);
    }
}

</->

packages/javascript-sdk/src/transport/https.ts
<->
import { Transport } from '../core/types';
import { getLogger } from '../utils/logger';
import { Config } from '@/core/config';
import * as https from 'https';
import * as url from 'url';

export class HttpsTransport implements Transport {
    private config: Config;

    constructor(private trackingHost: string, config: Config) {
        this.config = config;
    }

    async send(payloads: any[]): Promise<void> {
        const apiKey = this.config.key;
        const urlObject = new url.URL(this.constructUrl(apiKey));

        const options = {
            hostname: urlObject.hostname,
            port: 443,
            path: `${urlObject.pathname}${urlObject.search}`,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...this.getCustomHeaders()
            }
        };

        return new Promise<void>((resolve, reject) => {
            const req = https.request(options, (res) => {
                let data = '';

                res.on('data', (chunk) => {
                    data += chunk;
                });

                res.on('end', () => {
                    const statusCode = res.statusCode || 0;  // Default to 0 if undefined
                    if (statusCode >= 200 && statusCode < 300) {
                        getLogger().debug(`Successfully sent ${payloads.length} event(s)`);
                        resolve();
                    } else {
                        reject(new Error(`HTTP error! status: ${statusCode}`));
                    }
                });
            });

            req.on('error', (error) => {
                reject(error);
            });

            req.write(JSON.stringify(payloads));
            req.end();
        });
    }

    private constructUrl(apiKey: string): string {
        const cookiePolicy = this.config.cookiePolicy !== "keep" ? `&cookie_policy=${this.config.cookiePolicy}` : "";
        const ipPolicy = this.config.ipPolicy !== "keep" ? `&ip_policy=${this.config.ipPolicy}` : "";
        return `${this.trackingHost}/api/v1/s2s/event?token=${apiKey}${cookiePolicy}${ipPolicy}`;
    }

    private getCustomHeaders(): Record<string, string> {
        if (typeof this.config.customHeaders === 'function') {
            return this.config.customHeaders();
        } else if (this.config.customHeaders) {
            return this.config.customHeaders;
        }
        return {};
    }
}

</->

packages/javascript-sdk/src/transport/transport.ts
<->
export interface Transport {
    send(payload: any | any[]): Promise<void>;
}

</->

packages/javascript-sdk/src/transport/xhr.ts
<->
import { Transport } from '../core/types';
import { getLogger } from '../utils/logger';
import { isWindowAvailable, generateRandom } from "../utils/common";
import { Config } from '@/core/config';

export class XhrTransport implements Transport {
    private config: Config;

    constructor(private trackingHost: string, config: Config) {
        this.config = config;
    }

    send(payloads: any[]): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const apiKey = this.config.key;

            const url = this.constructUrl(apiKey);

            xhr.open('POST', url, true);
            xhr.setRequestHeader('Content-Type', 'application/json');

            // Set custom headers
            const customHeaders = this.getCustomHeaders();
            Object.keys(customHeaders).forEach(key => {
                xhr.setRequestHeader(key, customHeaders[key]);
            });

            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    getLogger().debug(`Successfully sent ${payloads.length} event(s)`);
                    resolve();
                } else {
                    reject(new Error(`HTTP error! status: ${xhr.status}`));
                }
            };

            xhr.onerror = () => {
                reject(new Error('Network error'));
            };

            xhr.send(JSON.stringify(payloads));
        });
    }

    private constructUrl(apiKey: string): string {
        const cookiePolicy = this.config.cookiePolicy !== "keep" ? `&cookie_policy=${this.config.cookiePolicy}` : "";
        const ipPolicy = this.config.ipPolicy !== "keep" ? `&ip_policy=${this.config.ipPolicy}` : "";
        const urlPrefix = isWindowAvailable() ? "/api/v1/event" : "/api/v1/s2s/event";

        if (this.config.randomizeUrl) {
            return `${this.trackingHost}/api.${generateRandom()}?p_${generateRandom()}=${apiKey}${cookiePolicy}${ipPolicy}`;
        } else {
            return `${this.trackingHost}${urlPrefix}?token=${apiKey}${cookiePolicy}${ipPolicy}`;
        }
    }

    private getCustomHeaders(): Record<string, string> {
        if (typeof this.config.customHeaders === 'function') {
            return this.config.customHeaders();
        } else if (this.config.customHeaders) {
            return this.config.customHeaders;
        }
        return {};
    }

    private postHandle(code: number, body: string): void {
        // Implement post-handling logic if needed
        getLogger().debug(`Response received. Status: ${code}, Body: ${body}`);
    }
}

</->

packages/javascript-sdk/src/utils/autocapture-utils.ts
<->
/*
 * Get the className of an element, accounting for edge cases where element.className is an object
 * @param {Element} el - element to get the className of
 * @returns {string} the element's class
 */
import { _each, _includes, _isUndefined, _trim } from './common'

export function getClassName(el: Element): string {
    switch (typeof el.className) {
        case 'string':
            return el.className
        // TODO: when is this ever used?
        case 'object': // handle cases where className might be SVGAnimatedString or some other type
            return ('baseVal' in el.className ? (el.className as any).baseVal : null) || el.getAttribute('class') || ''
        default:
            // future proof
            return ''
    }
}

/*
 * Get the direct text content of an element, protecting against sensitive data collection.
 * Concats textContent of each of the element's text node children; this avoids potential
 * collection of sensitive data that could happen if we used element.textContent and the
 * element had sensitive child elements, since element.textContent includes child content.
 * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).
 * @param {Element} el - element to get the text of
 * @returns {string} the element's direct text content
 */
export function getSafeText(el: Element): string {
    let elText = ''

    if (shouldCaptureElement(el) && !isSensitiveElement(el) && el.childNodes && el.childNodes.length) {
        _each(el.childNodes, function (child) {
            if (isTextNode(child) && child.textContent) {
                elText += _trim(child.textContent)
                    // scrub potentially sensitive values
                    .split(/(\s+)/)
                    .filter(shouldCaptureValue)
                    .join('')
                    // normalize whitespace
                    .replace(/[\r\n]/g, ' ')
                    .replace(/[ ]+/g, ' ')
                    // truncate
                    .substring(0, 255)
            }
        })
    }

    return _trim(elText)
}

/*
 * Check whether an element has nodeType Node.ELEMENT_NODE
 * @param {Element} el - element to check
 * @returns {boolean} whether el is of the correct nodeType
 */
export function isElementNode(el: Element | undefined | null): el is HTMLElement {
    return !!el && el.nodeType === 1 // Node.ELEMENT_NODE - use integer constant for browser portability
}

/*
 * Check whether an element is of a given tag type.
 * Due to potential reference discrepancies (such as the webcomponents.js polyfill),
 * we want to match tagNames instead of specific references because something like
 * element === document.body won't always work because element might not be a native
 * element.
 * @param {Element} el - element to check
 * @param {string} tag - tag name (e.g., "div")
 * @returns {boolean} whether el is of the given tag type
 */
export function isTag(el: Element | undefined | null, tag: string): el is HTMLElement {
    return !!el && !!el.tagName && el.tagName.toLowerCase() === tag.toLowerCase()
}

/*
 * Check whether an element has nodeType Node.TEXT_NODE
 * @param {Element} el - element to check
 * @returns {boolean} whether el is of the correct nodeType
 */
export function isTextNode(el: Element | undefined | null): el is HTMLElement {
    return !!el && el.nodeType === 3 // Node.TEXT_NODE - use integer constant for browser portability
}

/*
 * Check whether an element has nodeType Node.DOCUMENT_FRAGMENT_NODE
 * @param {Element} el - element to check
 * @returns {boolean} whether el is of the correct nodeType
 */
export function isDocumentFragment(el: Element | ParentNode | undefined | null): el is DocumentFragment {
    return !!el && el.nodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE - use integer constant for browser portability
}

export const usefulElements = ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']
/*
 * Check whether a DOM event should be "captured" or if it may contain sentitive data
 * using a variety of heuristics.
 * @param {Element} el - element to check
 * @param {Event} event - event to check
 * @returns {boolean} whether the event should be captured
 */
export function shouldCaptureDomEvent(el: Element, event: Event): boolean {
    if (!el || isTag(el, 'html') || !isElementNode(el)) {
        return false
    }

    // allow users to programmatically prevent capturing of elements by adding class 'um-no-capture'
    if (el.classList && el.classList.contains('um-no-capture')) {
        return false
    }

    let parentIsUsefulElement = false
    const targetElementList: Element[] = [el] // TODO: remove this var, it's never queried
    let parentNode: Element | boolean = true
    let curEl: Element = el
    while (curEl.parentNode && !isTag(curEl, 'body')) {
        // If element is a shadow root, we skip it
        if (isDocumentFragment(curEl.parentNode)) {
            targetElementList.push((curEl.parentNode as any).host)
            curEl = (curEl.parentNode as any).host
            continue
        }
        parentNode = (curEl.parentNode as Element) || false
        if (!parentNode) break
        if (usefulElements.indexOf(parentNode.tagName.toLowerCase()) > -1) {
            parentIsUsefulElement = true
        } else {
            const compStyles = window.getComputedStyle(parentNode)
            if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer') {
                parentIsUsefulElement = true
            }
        }

        targetElementList.push(parentNode)
        curEl = parentNode
    }

    const compStyles = window.getComputedStyle(el)
    if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer' && event.type === 'click') {
        return true
    }

    const tag = el.tagName.toLowerCase()
    switch (tag) {
        case 'html':
            return false
        case 'form':
            return event.type === 'submit'
        case 'input':
            return event.type === 'change' || event.type === 'click'
        case 'select':
        case 'textarea':
            return event.type === 'change' || event.type === 'click'
        default:
            if (parentIsUsefulElement) return event.type === 'click'
            return (
                event.type === 'click' &&
                (usefulElements.indexOf(tag) > -1 || el.getAttribute('contenteditable') === 'true')
            )
    }
}

/*
 * Check whether a DOM element should be "captured" or if it may contain sentitive data
 * using a variety of heuristics.
 * @param {Element} el - element to check
 * @returns {boolean} whether the element should be captured
 */
export function shouldCaptureElement(el: Element): boolean {
    for (let curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode as Element) {
        const classes = getClassName(curEl).split(' ')
        if (_includes(classes, 'ph-sensitive') || _includes(classes, 'ph-no-capture')) {
            return false
        }
    }

    if (_includes(getClassName(el).split(' '), 'ph-include')) {
        return true
    }

    // don't include hidden or password fields
    const type = (el as HTMLInputElement).type || ''
    if (typeof type === 'string') {
        // it's possible for el.type to be a DOM element if el is a form with a child input[name="type"]
        switch (type.toLowerCase()) {
            case 'hidden':
                return false
            case 'password':
                return false
        }
    }

    // filter out data from fields that look like sensitive fields
    const name = (el as HTMLInputElement).name || el.id || ''
    // See https://github.com/posthog/posthog-js/issues/165
    // Under specific circumstances a bug caused .replace to be called on a DOM element
    // instead of a string, removing the element from the page. Ensure this issue is mitigated.
    if (typeof name === 'string') {
        // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name="name"]
        const sensitiveNameRegex =
            /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i
        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {
            return false
        }
    }

    return true
}

/*
 * Check whether a DOM element is 'sensitive' and we should only capture limited data
 * @param {Element} el - element to check
 * @returns {boolean} whether the element should be captured
 */
export function isSensitiveElement(el: Element): boolean {
    // don't send data from inputs or similar elements since there will always be
    // a risk of clientside javascript placing sensitive data in attributes
    const allowedInputTypes = ['button', 'checkbox', 'submit', 'reset']
    if (
        (isTag(el, 'input') && !allowedInputTypes.includes((el as HTMLInputElement).type)) ||
        isTag(el, 'select') ||
        isTag(el, 'textarea') ||
        el.getAttribute('contenteditable') === 'true'
    ) {
        return true
    }
    return false
}

/*
 * Check whether a string value should be "captured" or if it may contain sentitive data
 * using a variety of heuristics.
 * @param {string} value - string value to check
 * @returns {boolean} whether the element should be captured
 */
export function shouldCaptureValue(value: string): boolean {
    if (value === null || _isUndefined(value)) {
        return false
    }

    if (typeof value === 'string') {
        value = _trim(value)

        // check to see if input value looks like a credit card number
        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html
        const ccRegex =
            /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/
        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {
            return false
        }

        // check to see if input value looks like a social security number
        const ssnRegex = /(^\d{3}-?\d{2}-?\d{4}$)/
        if (ssnRegex.test(value)) {
            return false
        }
    }

    return true
}

/*
 * Check whether an attribute name is an Angular style attr (either _ngcontent or _nghost)
 * These update on each build and lead to noise in the element chain
 * More details on the attributes here: https://angular.io/guide/view-encapsulation
 * @param {string} attributeName - string value to check
 * @returns {boolean} whether the element is an angular tag
 */
export function isAngularStyleAttr(attributeName: string): boolean {
    if (typeof attributeName === 'string') {
        return attributeName.substring(0, 10) === '_ngcontent' || attributeName.substring(0, 7) === '_nghost'
    }
    return false
}

export function loadScript(scriptUrlToLoad: string, callback: (event: Event) => void): void {
    const scriptTag = document.createElement('script')
    scriptTag.type = 'text/javascript'
    scriptTag.src = scriptUrlToLoad
    scriptTag.onload = callback

    const scripts = document.getElementsByTagName('script')
    if (scripts.length > 0) {
        scripts[0].parentNode?.insertBefore(scriptTag, scripts[0])
    } else {
        document.body.appendChild(scriptTag)
    }
}


</->

packages/javascript-sdk/src/utils/common.ts
<->
import {getLogger} from "./logger";

export type Breaker = {}
export type EventHandler = (event: Event) => boolean | void
const ObjProto = Object.prototype
const toString = ObjProto.toString
const hasOwnProperty = ObjProto.hasOwnProperty


const ArrayProto = Array.prototype
const nativeForEach = ArrayProto.forEach,
    nativeIndexOf = ArrayProto.indexOf,
    nativeIsArray = Array.isArray,
    breaker: Breaker = {}


export const _isArray =
    nativeIsArray ||
    function (obj: any): obj is any[] {
        return toString.call(obj) === '[object Array]'
    }

export function _eachArray<E = any>(
    obj: E[] | null | undefined,
    iterator: (value: E, key: number) => void | Breaker,
    thisArg?: any
): void {
    if (Array.isArray(obj)) {
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, thisArg)
        } else if ('length' in obj && obj.length === +obj.length) {
            for (let i = 0, l = obj.length; i < l; i++) {
                if (i in obj && iterator.call(thisArg, obj[i], i) === breaker) {
                    return
                }
            }
        }
    }
}
// Embed part of the Underscore Library
export const _trim = function (str: string): string {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
}

export const _bind_instance_methods = function (obj: Record<string, any>): void {
    for (const func in obj) {
        if (typeof obj[func] === 'function') {
            obj[func] = obj[func].bind(obj)
        }
    }
}

/**
 * @param {*=} obj
 * @param {function(...*)=} iterator
 * @param {Object=} thisArg
 */
export function _each(obj: any, iterator: (value: any, key: any) => void | Breaker, thisArg?: any): void {
    if (obj === null || obj === undefined) {
        return
    }
    if (nativeForEach && Array.isArray(obj) && obj.forEach === nativeForEach) {
        obj.forEach(iterator, thisArg)
    } else if ('length' in obj && obj.length === +obj.length) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(thisArg, obj[i], i) === breaker) {
                return
            }
        }
    } else {
        for (const key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                if (iterator.call(thisArg, obj[key], key) === breaker) {
                    return
                }
            }
        }
    }
}
export const _extend = function (obj: Record<string, any>, ...args: Record<string, any>[]): Record<string, any> {
    _eachArray(args, function (source) {
        for (const prop in source) {
            if (source[prop] !== void 0) {
                obj[prop] = source[prop]
            }
        }
    })
    return obj
}
export function _includes<T = any>(str: T[] | string, needle: T): boolean {
    return (str as any).indexOf(needle) !== -1
}

// from a comment on http://dbj.org/dbj/?p=286
// fails on only one very rare and deliberate custom object:
// let bomb = { toString : undefined, valueOf: function(o) { return "function BOMBA!"; }};
export const _isFunction = function (f: any): f is (...args: any[]) => any {
    try {
        return /^\s*\bfunction\b/.test(f)
    } catch (x) {
        return false
    }
}
export const _isUndefined = function (obj: any): obj is undefined {
    return obj === void 0
}

export const _register_event = (function () {
    // written by Dean Edwards, 2005
    // with input from Tino Zijdel - crisp@xs4all.nl
    // with input from Carl Sverre - mail@carlsverre.com
    // with input from PostHog
    // http://dean.edwards.name/weblog/2005/10/add-event/
    // https://gist.github.com/1930440

    /**
     * @param {Object} element
     * @param {string} type
     * @param {function(...*)} handler
     * @param {boolean=} oldSchool
     * @param {boolean=} useCapture
     */
    const register_event = function (
        element: Element | Window | Document | Node,
        type: string,
        handler: EventHandler,
        oldSchool?: boolean,
        useCapture?: boolean
    ) {
        if (!element) {
            getLogger().error('No valid element provided to register_event')
            return
        }

        if (element.addEventListener && !oldSchool) {
            // @ts-ignore
            element.addEventListener(type, handler, !!useCapture)
        } else {
            const ontype = 'on' + type
            const old_handler = (element as any)[ontype] // can be undefined
            ;(element as any)[ontype] = makeHandler(element, handler, old_handler)
        }
    }

    function makeHandler(
        element: Element | Window | Document | Node,
        new_handler: EventHandler,
        old_handlers: EventHandler
    ) {
        return function (event: Event): boolean | void {
            event = event || fixEvent(window.event)

            // this basically happens in firefox whenever another scripts
            // overwrites the onload callback and doesn't pass the event
            // object to previously defined callbacks.  All the browsers
            // that don't define window.event implement addEventListener
            // so the dom_loaded handler will still be fired as usual.
            if (!event) {
                return undefined
            }

            let ret = true
            let old_result: any

            if (_isFunction(old_handlers)) {
                old_result = old_handlers(event)
            }
            const new_result = new_handler.call(element, event)

            if (false === old_result || false === new_result) {
                ret = false
            }

            return ret
        }
    }

    function fixEvent(event: Event | undefined): Event | undefined {
        if (event) {
            event.preventDefault = fixEvent.preventDefault
            event.stopPropagation = fixEvent.stopPropagation
        }
        return event
    }
    fixEvent.preventDefault = function () {
        ;(this as any as Event).returnValue = false
    }
    fixEvent.stopPropagation = function () {
        ;(this as any as Event).cancelBubble = true
    }

    return register_event
})()


export const _safewrap = function <F extends (...args: any[]) => any = (...args: any[]) => any>(f: F): F {
    return function (...args) {
        try {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            return f.apply(this, args)
        } catch (e) {
            getLogger().error('Implementation error. Please turn on debug and contact support@usermaven.com.', e)
            // if (Config.DEBUG) {
            //     getLogger.critical(e)
            // }
        }
    } as F
}


export const _safewrap_instance_methods = function (obj: Record<string, any>): void {
    for (const func in obj) {
        if (typeof obj[func] === 'function') {
            obj[func] = _safewrap(obj[func])
        }
    }
}

const COPY_IN_PROGRESS_ATTRIBUTE =
    typeof Symbol !== 'undefined' ? Symbol('__deepCircularCopyInProgress__') : '__deepCircularCopyInProgress__'


/**
 * Deep copies an object.
 * It handles cycles by replacing all references to them with `undefined`
 * Also supports customizing native values
 *
 * @param value
 * @param customizer
 * @param [key] if provided this is the object key associated with the value to be copied. It allows the customizer function to have context when it runs
 * @returns {{}|undefined|*}
 */
function deepCircularCopy<T extends Record<string, any> = Record<string, any>>(
    value: T,
    customizer?: <K extends keyof T = keyof T>(value: T[K], key?: K) => T[K],
    key?: string
): T | undefined {
    if (value !== Object(value)) return customizer ? customizer(value as any, key) : value // primitive value

    if (value[COPY_IN_PROGRESS_ATTRIBUTE as any]) return undefined
        ;(value as any)[COPY_IN_PROGRESS_ATTRIBUTE] = true
    let result: T

    if (_isArray(value)) {
        result = [] as any as T
        _eachArray(value, (it) => {
            result.push(deepCircularCopy(it, customizer))
        })
    } else {
        result = {} as T
        _each(value, (val, key) => {
            if (key !== COPY_IN_PROGRESS_ATTRIBUTE) {
                ;(result as any)[key] = deepCircularCopy(val, customizer, key)
            }
        })
    }
    delete value[COPY_IN_PROGRESS_ATTRIBUTE as any]
    return result
}


const LONG_STRINGS_ALLOW_LIST = ['$performance_raw']

export function _copyAndTruncateStrings<T extends Record<string, any> = Record<string, any>>(
    object: T,
    maxStringLength: number | null
): T {
    return deepCircularCopy(object, (value: any, key) => {
        if (key && LONG_STRINGS_ALLOW_LIST.indexOf(key as string) > -1) {
            return value
        }
        if (typeof value === 'string' && maxStringLength !== null) {
            return (value as string).slice(0, maxStringLength)
        }
        return value
    }) as T
}

// This is to block various web spiders from executing our JS and
// sending false capturing data
export const _isBlockedUA = function (ua: string): boolean {
    if (
        /(google web preview|baiduspider|yandexbot|bingbot|googlebot|yahoo! slurp|ahrefsbot|facebookexternalhit|facebookcatalog)/i.test(
            ua
        )
    ) {
        return true
    }
    return false
}

// Function to find the closest link element
export function _findClosestLink(element: HTMLElement | null): HTMLElement | null {
    while (element && element.tagName) {
        if (element.tagName.toLowerCase() == 'a') {
            return element;
        }
        element = element.parentNode as HTMLElement | null;
    }
    return null;
}


export function _cleanObject(obj: Record<string, any>) {
    for (let propName in obj) {
        if (obj[propName] === '' || obj[propName] === null || obj[propName] === undefined || (typeof obj[propName] === 'object' && Object.keys(obj[propName]).length === 0)) {
            delete obj[propName];
        }
    }
    return obj;
}

export function isWindowAvailable(): boolean {
    try {
        return typeof window !== 'undefined' &&
            window.document !== undefined &&
            window.document.createElement !== undefined;
    } catch (e) {
        getLogger().error('window is not available')
        return false;
    }
}


export function  generateRandom(): string {
    return Math.random().toString(36).substring(2, 7)
}

</->

packages/javascript-sdk/src/utils/cookie.ts
<->
export class CookieManager {
    private cookieDomain: string;

    constructor(private domain?: string) {
        this.cookieDomain = this.getCookieDomain();
    }

    set(name: string, value: string, expirationDays: number = 365, secure: boolean = true, httpOnly: boolean = false): void {
        const date = new Date();
        date.setTime(date.getTime() + expirationDays * 24 * 60 * 60 * 1000);
        const expires = `expires=${date.toUTCString()}`;
        const secureFlag = secure ? '; Secure' : '';
        const httpOnlyFlag = httpOnly ? '; HttpOnly' : '';
        document.cookie = `${name}=${value};${expires};path=/;domain=${this.cookieDomain}${secureFlag}${httpOnlyFlag}`;
    }

    get(name: string): string | null {
        const cookieName = `${name}=`;
        const decodedCookie = decodeURIComponent(document.cookie);
        const cookieArray = decodedCookie.split(';');
        for (let i = 0; i < cookieArray.length; i++) {
            let cookie = cookieArray[i].trim();
            if (cookie.indexOf(cookieName) === 0) {
                return cookie.substring(cookieName.length);
            }
        }
        return null;
    }

    delete(name: string): void {
        document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;domain=${this.cookieDomain}`;
    }

    private getCookieDomain(): string {
        if (typeof window === 'undefined' || this.domain) {
            return this.domain || '';
        }
        return '.' + this.extractRoot(window.location.hostname);
    }

    private extractRoot(url: string): string {
        const domainParts = url.split(".");
        const domainLength = domainParts.length;

        // Check if it's an IP address
        if (domainLength === 4 && domainParts.every(part => !isNaN(Number(part)))) {
            return url;
        }

        let rootDomain = this.extractTopLevelDomain(url);
        if (!rootDomain) { // If it's not a top level domain, use a fallback method
            rootDomain = this.extractRootDomain(url);
        }

        return rootDomain;
    }

    private extractTopLevelDomain(url: string): string {
        const DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i;
        const matches = url.match(DOMAIN_MATCH_REGEX);
        return matches ? matches[0] : '';
    }

    private extractRootDomain(url: string): string {
        let domain = this.extractHostname(url);
        const splitArr = domain.split('.');
        const arrLen = splitArr.length;

        // extracting the root domain here
        // if there is a subdomain
        if (arrLen > 2) {
            if (splitArr[arrLen - 1].length == 2) {
                // likely a ccTLD
                domain = splitArr[arrLen - 2] + '.' + splitArr[arrLen - 1];
                // if the second level domain is also two letters (like co.uk), include the next part up
                if (splitArr[arrLen - 2].length == 2) {
                    domain = splitArr[arrLen - 3] + '.' + domain;
                }
            } else {
                // likely a gTLD
                domain = splitArr[arrLen - 2] + '.' + splitArr[arrLen - 1];
            }
        }
        return domain;
    }

    private extractHostname(url: string): string {
        let hostname: string;
        //find & remove protocol (http, ftp, etc.) and get hostname

        if (url.indexOf("//") > -1) {
            hostname = url.split('/')[2];
        } else {
            hostname = url.split('/')[0];
        }

        //find & remove port number
        hostname = hostname.split(':')[0];
        //find & remove "?"
        hostname = hostname.split('?')[0];

        return hostname;
    }
}

</->

packages/javascript-sdk/src/utils/helpers.ts
<->
import {LogLevel} from "../utils/logger";

export function generateId(): string {
    return Math.random().toString(36).substring(2, 12);
}

export function isValidEmail(email: string): boolean {
    const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(email).toLowerCase());
}

export function debounce<T extends (...args: P) => any, P extends any[]>(
    func: T,
    wait: number
): (...args: P) => void {
    let timeout: ReturnType<typeof setTimeout>;
    return function (...args: P): void {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

export function getUtmParams(): Record<string, string> {
    const utmParams: Record<string, string> = {};
    const queryParams = parseQueryString(window.location.search);
    const utmKeys = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'];

    utmKeys.forEach(key => {
        if (queryParams[key]) {
            utmParams[key.replace('utm_', '')] = queryParams[key];
        }
    });

    return utmParams;
}

export function parseQueryString(queryString: string): Record<string, string> {
    const params: Record<string, string> = {};
    const queries = queryString.substring(1).split('&');

    for (let i = 0; i < queries.length; i++) {
        const pair = queries[i].split('=');
        params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
    }

    return params;
}

export function isString(value: any): boolean {
    return typeof value === 'string' || value instanceof String;
}

export function isObject(value: any): boolean {
    return value && typeof value === 'object' && value.constructor === Object;
}


export function parseLogLevel(value: string | null): LogLevel {
    if (value === null) {
        return LogLevel.WARN; // Default value
    }

    const upperValue = value.toUpperCase();
    return (LogLevel[upperValue as keyof typeof LogLevel] as LogLevel) || LogLevel.WARN;
}

</->

packages/javascript-sdk/src/utils/logger.ts
<->
export enum LogLevel {
    DEBUG,
    INFO,
    WARN,
    ERROR,
}

export class Logger {
    constructor(private level: LogLevel) {}

    debug(message: string, ...args: any[]): void {
        if (this.level <= LogLevel.DEBUG) {
            console.debug(`[Usermaven Debug]:`, message, ...args);
        }
    }

    info(message: string, ...args: any[]): void {
        if (this.level <= LogLevel.INFO) {
            console.info(`[Usermaven Info]:`, message, ...args);
        }
    }

    warn(message: string, ...args: any[]): void {
        if (this.level <= LogLevel.WARN) {
            console.warn(`[Usermaven Warning]:`, message, ...args);
        }
    }

    error(message: string, ...args: any[]): void {
        if (this.level <= LogLevel.ERROR) {
            console.error(`[Usermaven Error]:`, message, ...args);
        }
    }
}

export function getLogger(): Logger {
    return new Logger(LogLevel.DEBUG);
}

</->

packages/javascript-sdk/src/utils/queue.ts
<->
import { Transport } from '../core/types';
import { getLogger } from '../utils/logger';
import { LocalStoragePersistence } from '../persistence/local-storage';
import { isWindowAvailable } from '../utils/common';

export class RetryQueue {
    private queue: QueueItem[] = [];
    private processing: boolean = false;
    private batchTimeoutId: number | null = null;
    private persistence: LocalStoragePersistence;
    private isOnline: boolean = true; // Default to true for server-side

    constructor(
        private transport: Transport,
        private maxRetries: number = 3,
        private retryInterval: number = 1000,
        private batchSize: number = 10,
        private batchInterval: number = 1000
    ) {
        this.persistence = new LocalStoragePersistence('offline_queue');
        if (isWindowAvailable()) {
            this.isOnline = navigator.onLine;
            this.loadQueueFromStorage();
            this.initNetworkListeners();
            this.scheduleBatch();
        }
    }

    add(payload: any): void {
        const item = { payload, retries: 0, timestamp: Date.now() };
        this.queue.push(item);
        if (isWindowAvailable()) {
            this.saveQueueToStorage();
        } else {
            this.processBatch(); // Immediately process on server-side
        }
    }

    private initNetworkListeners(): void {
        if (isWindowAvailable()) {
            window.addEventListener('online', () => {
                this.isOnline = true;
                this.processBatch();
            });
            window.addEventListener('offline', () => {
                this.isOnline = false;
            });
        }
    }

    private scheduleBatch(): void {
        if (!isWindowAvailable()) return;

        if (this.batchTimeoutId !== null) {
            clearTimeout(this.batchTimeoutId);
        }

        this.batchTimeoutId = window.setTimeout(() => this.processBatch(), this.batchInterval);
    }

    private async processBatch(): Promise<void> {
        if ((!isWindowAvailable() || this.isOnline) && !this.processing && this.queue.length > 0) {
            this.processing = true;
            const batch = this.queue.splice(0, this.batchSize);
            const payloads = batch.map(item => item.payload);

            try {
                await this.transport.send(payloads);
                getLogger().debug(`Successfully sent batch of ${batch.length} payloads`);
                if (isWindowAvailable()) {
                    this.saveQueueToStorage();
                }
            } catch (error) {
                getLogger().error('Failed to send batch', error);
                await this.handleBatchFailure(batch);
            }

            this.processing = false;
        }

        if (isWindowAvailable()) {
            this.scheduleBatch();
        }
    }

    private async handleBatchFailure(batch: QueueItem[]): Promise<void> {
        for (const item of batch) {
            if (item.retries < this.maxRetries) {
                item.retries++;
                this.queue.unshift(item);
                getLogger().warn(`Retry attempt ${item.retries} for payload`);
            } else {
                getLogger().error('Max retries reached, discarding payload', item.payload);
            }
        }

        if (isWindowAvailable()) {
            this.saveQueueToStorage();
            await new Promise(resolve => setTimeout(resolve, this.retryInterval));
        }
    }

    private loadQueueFromStorage(): void {
        if (isWindowAvailable()) {
            const storedQueue = this.persistence.get('queue');
            if (storedQueue) {
                this.queue = JSON.parse(storedQueue);
            }
        }
    }

    private saveQueueToStorage(): void {
        if (isWindowAvailable()) {
            this.persistence.set('queue', JSON.stringify(this.queue));
        }
    }
}

interface QueueItem {
    payload: any;
    retries: number;
    timestamp: number;
}

</->

packages/javascript-sdk/test/setup.ts
<->
import '@testing-library/jest-dom';
import { vi } from 'vitest';

// Mock XMLHttpRequest
global.XMLHttpRequest = vi.fn(() => ({
    open: vi.fn(),
    send: vi.fn(),
    setRequestHeader: vi.fn(),
})) as any;

global.fetch = vi.fn() as any;

// Mock localStorage
const localStorageMock = {
    getItem: vi.fn(),
    setItem: vi.fn(),
    clear: vi.fn(),
    length: 0,
    key: vi.fn(),
    removeItem: vi.fn(),
};
Object.defineProperty(global, 'localStorage', { value: localStorageMock });

// Mock navigator
Object.defineProperty(global.navigator, 'sendBeacon', {
    value: vi.fn(),
});

</->

packages/javascript-sdk/test/unit/core/client.test.ts
<->
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { UsermavenClient } from '../../../src/core/client';
import { Config } from '../../../src/core/config';

describe('UsermavenClient', () => {
    let client: UsermavenClient;
    const mockConfig: Config = {
        key: 'test-api-key',
        trackingHost: 'https://test.usermaven.com',
    };

    beforeEach(() => {
        client = new UsermavenClient(mockConfig);
        vi.spyOn(client, 'track').mockImplementation((typeName, payload) => {
            if (typeof typeName !== 'string') {
                throw new Error('Event name must be a string');
            }
            if (payload !== undefined && (typeof payload !== 'object' || payload === null || Array.isArray(payload))) {
                throw new Error('Event payload must be a non-null object and not an array');
            }
        });
        vi.spyOn(client['retryQueue'], 'add').mockImplementation(() => {});
    });

    afterEach(() => {
        vi.restoreAllMocks();
    });

    describe('id method', () => {
        it('should set user properties and send identify event', async () => {
            const userData = { id: 'user123', email: 'test@example.com' };
            await client.id(userData);

            expect(client.track).toHaveBeenCalledWith('user_identify', expect.objectContaining(userData));
        });

        it('should not send event when doNotSendEvent is true', async () => {
            const userData = { id: 'user123', email: 'test@example.com' };
            await client.id(userData, true);

            expect(client.track).not.toHaveBeenCalled();
        });

        it('should throw an error for invalid email', () => {
            const userData = { id: 'user123', email: 'invalid-email' };
            expect(() => client.id(userData)).rejects.toThrow('Invalid email provided');
        });
    });

    describe('track method', () => {
        it('should track an event with correct payload', () => {
            const eventName = 'test_event';
            const eventPayload = { key: 'value' };
            expect(() => client.track(eventName, eventPayload)).not.toThrow();
        });

        it('should throw an error for non-string event names', () => {
            expect(() => client.track(123 as any)).toThrow('Event name must be a string');
        });

        it('should throw an error for non-object payloads', () => {
            expect(() => client.track('test_event', 'invalid_payload' as any)).toThrow('Event payload must be a non-null object and not an array');
        });

        it('should not throw an error when payload is undefined', () => {
            expect(() => client.track('test_event')).not.toThrow();
        });

        it('should throw an error for null payload', () => {
            expect(() => client.track('test_event', null as any)).toThrow('Event payload must be a non-null object and not an array');
        });

        it('should throw an error for array payload', () => {
            expect(() => client.track('test_event', [] as any)).toThrow('Event payload must be a non-null object and not an array');
        });

        it('should not throw an error for empty object payload', () => {
            expect(() => client.track('test_event', {})).not.toThrow();
        });

        it('should not throw an error for complex nested object payload', () => {
            const complexPayload = {
                user: {
                    id: 1,
                    name: 'John Doe',
                    preferences: {
                        theme: 'dark',
                        notifications: true
                    }
                },
                items: [
                    { id: 1, name: 'Item 1' },
                    { id: 2, name: 'Item 2' }
                ]
            };
            expect(() => client.track('test_event', complexPayload)).not.toThrow();
        });
    });

    describe('group method', () => {
        it('should set company properties and send group event', async () => {
            const companyProps = { id: 'company123', name: 'Test Company', created_at: '2023-01-01' };
            await client.group(companyProps);

            expect(client.track).toHaveBeenCalledWith('group', expect.objectContaining(companyProps));
        });

        it('should not send event when doNotSendEvent is true', async () => {
            const companyProps = { id: 'company123', name: 'Test Company', created_at: '2023-01-01' };
            await client.group(companyProps, true);

            expect(client.track).not.toHaveBeenCalled();
        });

        it('should throw an error for invalid company properties', () => {
            const invalidProps = { id: 'company123' };
            expect(() => client.group(invalidProps as any)).rejects.toThrow('Company properties must include id, name, and created_at');
        });
    });

    describe('pageview method', () => {
        it('should track a pageview event', () => {
            client.pageview();

            expect(client.track).toHaveBeenCalledWith('pageview', expect.objectContaining({
                url: expect.any(String),
                referrer: expect.any(String),
                title: expect.any(String),
            }));
        });
    });

    describe('reset method', () => {
        it('should reset client state', async () => {
            const persistenceSpy = vi.spyOn(client['persistence'], 'clear');
            let cookieManagerDeleteCalled = false;

            if (client['cookieManager']) {
                vi.spyOn(client['cookieManager'], 'delete').mockImplementation(() => {
                    cookieManagerDeleteCalled = true;
                });
            }

            await client.reset();

            expect(persistenceSpy).toHaveBeenCalled();
            expect(cookieManagerDeleteCalled).toBe(false);
        });

        it('should reset client state and anonymous id when resetAnonId is true', async () => {
            const persistenceSpy = vi.spyOn(client['persistence'], 'clear');
            let cookieManagerDeleteCalled = false;

            if (client['cookieManager']) {
                vi.spyOn(client['cookieManager'], 'delete').mockImplementation(() => {
                    cookieManagerDeleteCalled = true;
                });
            }

            await client.reset(true);

            expect(persistenceSpy).toHaveBeenCalled();
            if (client['cookieManager']) {
                expect(cookieManagerDeleteCalled).toBe(true);
            } else {
                expect(cookieManagerDeleteCalled).toBe(false);
            }
        });
    });
});

</->

packages/javascript-sdk/test/unit/core/server-side-client.test.ts
<->
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { UsermavenClient } from '../../../src/core/client';
import { Config } from '../../../src/core/config';
import * as commonUtils from '../../../src/utils/common';
import * as helpers from '../../../src/utils/helpers';

describe('UsermavenClient (Server-side)', () => {
    let client: UsermavenClient;
    let trackSpy: ReturnType<typeof vi.fn>;
    const mockConfig: Config = {
        key: 'test-api-key',
        trackingHost: 'https://test.usermaven.com',
    };

    beforeEach(() => {
        vi.spyOn(commonUtils, 'isWindowAvailable').mockReturnValue(false);
        vi.spyOn(helpers, 'generateId').mockReturnValue('mocked-id');

        // Create a spy for the track method
        trackSpy = vi.fn();

        // Create the client instance
        client = new UsermavenClient(mockConfig);

        // Replace the track method with our spy
        client.track = trackSpy;
    });

    afterEach(() => {
        vi.restoreAllMocks();
    });

    it('should initialize without browser-specific features', () => {
        expect(client['autoCapture']).toBeUndefined();
        expect(client['formTracking']).toBeUndefined();
        expect(client['pageviewTracking']).toBeUndefined();
        expect(client['rageClick']).toBeUndefined();
        expect(client['cookieManager']).toBeUndefined();
    });

    it('should use HttpsTransport on server-side', () => {
        expect(client['transport'].constructor.name).toBe('HttpsTransport');
    });

    it('should track events on server-side', () => {
        const eventName = 'server_event';
        const eventPayload = { key: 'value' };
        client.track(eventName, eventPayload);
        expect(trackSpy).toHaveBeenCalledWith(eventName, eventPayload);
    });

    it('should identify users on server-side', async () => {
        const userData = { id: 'server_user_123', email: 'server@example.com' };
        await client.id(userData);
        expect(trackSpy).toHaveBeenCalledWith('user_identify', expect.objectContaining(userData));
    });

    it('should handle group method on server-side', async () => {
        const companyProps = { id: 'server_company_123', name: 'Server Company', created_at: '2023-01-01' };
        await client.group(companyProps);
        expect(trackSpy).toHaveBeenCalledWith('group', expect.objectContaining(companyProps));
    });

    it('should not throw error for pageview method on server-side', () => {
        expect(() => client.pageview()).not.toThrow();
        expect(trackSpy).not.toHaveBeenCalled();
    });

    it('should reset client state on server-side', async () => {
        const persistenceSpy = vi.spyOn(client['persistence'], 'clear');
        await client.reset();
        expect(persistenceSpy).toHaveBeenCalled();
    });

    it('should generate a new anonymous ID on server-side', () => {
        expect(client['anonymousId']).toBe('mocked-id');
        expect(helpers.generateId).toHaveBeenCalled();
    });

    it('should handle complex nested object payload', () => {
        const complexPayload = {
            user: {
                id: 1,
                name: 'John Doe',
                custom: {
                    theme: 'dark',
                    notifications: true
                }
            }
        };
        expect(() => client.track('complex_event', complexPayload)).not.toThrow();
        expect(trackSpy).toHaveBeenCalledWith('complex_event', complexPayload);
    });

    it('should throw an error for invalid company properties', () => {
        const invalidProps = { id: 'company123' };
        expect(() => client.group(invalidProps as any)).rejects.toThrow('Company properties must include id, name, and created_at');
    });
});

</->

packages/javascript-sdk/test/vitest.d.ts
<->
/// <reference types="vitest" />

import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';

declare global {
    namespace Vi {
        interface JestAssertion<T = any>
            extends jest.Matchers<void, T>,
                TestingLibraryMatchers<T, void> {}
    }

    interface Window {
        localStorage: Storage;
    }

    var localStorage: Storage;
    var XMLHttpRequest: new () => XMLHttpRequest;
}

export {};

</->

packages/javascript-sdk/tsconfig.json
<->
{
  "compilerOptions": {
    "target": "ES6",
    "module": "ESNext",
    "lib": ["DOM", "ESNext"],
    "moduleResolution": "node",
    "strict": true,
    "noImplicitAny": false,
    "noPropertyAccessFromIndexSignature": false,
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "noEmit": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["vite/client", "vitest/globals", "node"]
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.d.ts",
    "test/**/*.ts",
    "test/**/*.d.ts",
    "vitest.config.ts",
    "src/global.d.ts"
  ],
  "exclude": ["node_modules", "dist"]
}

</->

packages/javascript-sdk/vite.config.ts
<->
import { defineConfig } from 'vite';
import { resolve } from 'path';
import dts from 'vite-plugin-dts';

export default defineConfig(({ command, mode }) => {
    // Determine if we are in build mode
    const isBuild = command === 'build';

    return {
        build: {
            lib: {
                entry: resolve(__dirname, 'src/index.ts'),
                name: 'Usermaven',
                formats: ['es', 'cjs', 'umd'],
                fileName: (format) => {
                    if (format === 'umd') {
                        return 'lib.js';
                    }
                    return `usermaven.${format}.js`;
                },
            },
            rollupOptions: {
                external: [],  // Add external dependencies here if needed
                output: {
                    globals: {
                        module: 'module',
                    },
                },
            },
        },
        plugins: [
            // Conditionally include the dts plugin only during build
            isBuild && dts({
                insertTypesEntry: true,
                include: ['src/**/*.ts'],
                exclude: ['test', 'node_modules'],
                outDir: 'dist', // Changed from outputDir to outDir
            }),
            // Add other plugins here if needed
        ].filter(Boolean), // Filter out any falsey values (like 'false') to avoid Vite warnings
        server: {
            open: '/examples/index.html',
            watch: {
                usePolling: true,
                ignored: ['!**/dist/**']
            },
        },
        optimizeDeps: {
            exclude: ['@usermaven/sdk-js'],
        },
    };
});

</->

packages/javascript-sdk/vitest.config.ts
<->
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
    test: {
        globals: true,
        environment: 'jsdom',
        setupFiles: ['./test/setup.ts'],
        include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
        coverage: {
            provider: 'v8',
            reporter: ['text', 'json', 'html'],
        },
    },
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src'),
        },
    },
});

</->


